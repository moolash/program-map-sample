// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  class: (where?: ClassWhereInput) => Promise<boolean>;
  degree: (where?: DegreeWhereInput) => Promise<boolean>;
  meta: (where?: MetaWhereInput) => Promise<boolean>;
  noncurricular: (where?: NoncurricularWhereInput) => Promise<boolean>;
  program: (where?: ProgramWhereInput) => Promise<boolean>;
  requirement: (where?: RequirementWhereInput) => Promise<boolean>;
  term: (where?: TermWhereInput) => Promise<boolean>;
  year: (where?: YearWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  class: (where: ClassWhereUniqueInput) => ClassNullablePromise;
  classes: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Class>;
  classesConnection: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClassConnectionPromise;
  degree: (where: DegreeWhereUniqueInput) => DegreeNullablePromise;
  degrees: (args?: {
    where?: DegreeWhereInput;
    orderBy?: DegreeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Degree>;
  degreesConnection: (args?: {
    where?: DegreeWhereInput;
    orderBy?: DegreeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DegreeConnectionPromise;
  meta: (where: MetaWhereUniqueInput) => MetaNullablePromise;
  metas: (args?: {
    where?: MetaWhereInput;
    orderBy?: MetaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Meta>;
  metasConnection: (args?: {
    where?: MetaWhereInput;
    orderBy?: MetaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MetaConnectionPromise;
  noncurricular: (
    where: NoncurricularWhereUniqueInput
  ) => NoncurricularNullablePromise;
  noncurriculars: (args?: {
    where?: NoncurricularWhereInput;
    orderBy?: NoncurricularOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Noncurricular>;
  noncurricularsConnection: (args?: {
    where?: NoncurricularWhereInput;
    orderBy?: NoncurricularOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NoncurricularConnectionPromise;
  program: (where: ProgramWhereUniqueInput) => ProgramNullablePromise;
  programs: (args?: {
    where?: ProgramWhereInput;
    orderBy?: ProgramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Program>;
  programsConnection: (args?: {
    where?: ProgramWhereInput;
    orderBy?: ProgramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProgramConnectionPromise;
  requirement: (
    where: RequirementWhereUniqueInput
  ) => RequirementNullablePromise;
  requirements: (args?: {
    where?: RequirementWhereInput;
    orderBy?: RequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Requirement>;
  requirementsConnection: (args?: {
    where?: RequirementWhereInput;
    orderBy?: RequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RequirementConnectionPromise;
  term: (where: TermWhereUniqueInput) => TermNullablePromise;
  terms: (args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Term>;
  termsConnection: (args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TermConnectionPromise;
  year: (where: YearWhereUniqueInput) => YearNullablePromise;
  years: (args?: {
    where?: YearWhereInput;
    orderBy?: YearOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Year>;
  yearsConnection: (args?: {
    where?: YearWhereInput;
    orderBy?: YearOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => YearConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createClass: (data: ClassCreateInput) => ClassPromise;
  updateClass: (args: {
    data: ClassUpdateInput;
    where: ClassWhereUniqueInput;
  }) => ClassPromise;
  updateManyClasses: (args: {
    data: ClassUpdateManyMutationInput;
    where?: ClassWhereInput;
  }) => BatchPayloadPromise;
  upsertClass: (args: {
    where: ClassWhereUniqueInput;
    create: ClassCreateInput;
    update: ClassUpdateInput;
  }) => ClassPromise;
  deleteClass: (where: ClassWhereUniqueInput) => ClassPromise;
  deleteManyClasses: (where?: ClassWhereInput) => BatchPayloadPromise;
  createDegree: (data: DegreeCreateInput) => DegreePromise;
  updateDegree: (args: {
    data: DegreeUpdateInput;
    where: DegreeWhereUniqueInput;
  }) => DegreePromise;
  updateManyDegrees: (args: {
    data: DegreeUpdateManyMutationInput;
    where?: DegreeWhereInput;
  }) => BatchPayloadPromise;
  upsertDegree: (args: {
    where: DegreeWhereUniqueInput;
    create: DegreeCreateInput;
    update: DegreeUpdateInput;
  }) => DegreePromise;
  deleteDegree: (where: DegreeWhereUniqueInput) => DegreePromise;
  deleteManyDegrees: (where?: DegreeWhereInput) => BatchPayloadPromise;
  createMeta: (data: MetaCreateInput) => MetaPromise;
  updateMeta: (args: {
    data: MetaUpdateInput;
    where: MetaWhereUniqueInput;
  }) => MetaPromise;
  updateManyMetas: (args: {
    data: MetaUpdateManyMutationInput;
    where?: MetaWhereInput;
  }) => BatchPayloadPromise;
  upsertMeta: (args: {
    where: MetaWhereUniqueInput;
    create: MetaCreateInput;
    update: MetaUpdateInput;
  }) => MetaPromise;
  deleteMeta: (where: MetaWhereUniqueInput) => MetaPromise;
  deleteManyMetas: (where?: MetaWhereInput) => BatchPayloadPromise;
  createNoncurricular: (data: NoncurricularCreateInput) => NoncurricularPromise;
  updateNoncurricular: (args: {
    data: NoncurricularUpdateInput;
    where: NoncurricularWhereUniqueInput;
  }) => NoncurricularPromise;
  updateManyNoncurriculars: (args: {
    data: NoncurricularUpdateManyMutationInput;
    where?: NoncurricularWhereInput;
  }) => BatchPayloadPromise;
  upsertNoncurricular: (args: {
    where: NoncurricularWhereUniqueInput;
    create: NoncurricularCreateInput;
    update: NoncurricularUpdateInput;
  }) => NoncurricularPromise;
  deleteNoncurricular: (
    where: NoncurricularWhereUniqueInput
  ) => NoncurricularPromise;
  deleteManyNoncurriculars: (
    where?: NoncurricularWhereInput
  ) => BatchPayloadPromise;
  createProgram: (data: ProgramCreateInput) => ProgramPromise;
  updateProgram: (args: {
    data: ProgramUpdateInput;
    where: ProgramWhereUniqueInput;
  }) => ProgramPromise;
  upsertProgram: (args: {
    where: ProgramWhereUniqueInput;
    create: ProgramCreateInput;
    update: ProgramUpdateInput;
  }) => ProgramPromise;
  deleteProgram: (where: ProgramWhereUniqueInput) => ProgramPromise;
  deleteManyPrograms: (where?: ProgramWhereInput) => BatchPayloadPromise;
  createRequirement: (data: RequirementCreateInput) => RequirementPromise;
  updateRequirement: (args: {
    data: RequirementUpdateInput;
    where: RequirementWhereUniqueInput;
  }) => RequirementPromise;
  updateManyRequirements: (args: {
    data: RequirementUpdateManyMutationInput;
    where?: RequirementWhereInput;
  }) => BatchPayloadPromise;
  upsertRequirement: (args: {
    where: RequirementWhereUniqueInput;
    create: RequirementCreateInput;
    update: RequirementUpdateInput;
  }) => RequirementPromise;
  deleteRequirement: (where: RequirementWhereUniqueInput) => RequirementPromise;
  deleteManyRequirements: (
    where?: RequirementWhereInput
  ) => BatchPayloadPromise;
  createTerm: (data: TermCreateInput) => TermPromise;
  updateTerm: (args: {
    data: TermUpdateInput;
    where: TermWhereUniqueInput;
  }) => TermPromise;
  updateManyTerms: (args: {
    data: TermUpdateManyMutationInput;
    where?: TermWhereInput;
  }) => BatchPayloadPromise;
  upsertTerm: (args: {
    where: TermWhereUniqueInput;
    create: TermCreateInput;
    update: TermUpdateInput;
  }) => TermPromise;
  deleteTerm: (where: TermWhereUniqueInput) => TermPromise;
  deleteManyTerms: (where?: TermWhereInput) => BatchPayloadPromise;
  createYear: (data: YearCreateInput) => YearPromise;
  updateYear: (args: {
    data: YearUpdateInput;
    where: YearWhereUniqueInput;
  }) => YearPromise;
  updateManyYears: (args: {
    data: YearUpdateManyMutationInput;
    where?: YearWhereInput;
  }) => BatchPayloadPromise;
  upsertYear: (args: {
    where: YearWhereUniqueInput;
    create: YearCreateInput;
    update: YearUpdateInput;
  }) => YearPromise;
  deleteYear: (where: YearWhereUniqueInput) => YearPromise;
  deleteManyYears: (where?: YearWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  class: (
    where?: ClassSubscriptionWhereInput
  ) => ClassSubscriptionPayloadSubscription;
  degree: (
    where?: DegreeSubscriptionWhereInput
  ) => DegreeSubscriptionPayloadSubscription;
  meta: (
    where?: MetaSubscriptionWhereInput
  ) => MetaSubscriptionPayloadSubscription;
  noncurricular: (
    where?: NoncurricularSubscriptionWhereInput
  ) => NoncurricularSubscriptionPayloadSubscription;
  program: (
    where?: ProgramSubscriptionWhereInput
  ) => ProgramSubscriptionPayloadSubscription;
  requirement: (
    where?: RequirementSubscriptionWhereInput
  ) => RequirementSubscriptionPayloadSubscription;
  term: (
    where?: TermSubscriptionWhereInput
  ) => TermSubscriptionPayloadSubscription;
  year: (
    where?: YearSubscriptionWhereInput
  ) => YearSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ClassOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "className_ASC"
  | "className_DESC"
  | "number_ASC"
  | "number_DESC"
  | "sortorder_ASC"
  | "sortorder_DESC"
  | "subject_ASC"
  | "subject_DESC"
  | "subsortorder_ASC"
  | "subsortorder_DESC"
  | "url_ASC"
  | "url_DESC";

export type DegreeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "heading_ASC"
  | "heading_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "pathurl_ASC"
  | "pathurl_DESC";

export type ProgramOrderByInput = "id_ASC" | "id_DESC";

export type YearOrderByInput = "id_ASC" | "id_DESC" | "year_ASC" | "year_DESC";

export type TermOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "term_ASC"
  | "term_DESC"
  | "termName_ASC"
  | "termName_DESC"
  | "yearTermTitle_ASC"
  | "yearTermTitle_DESC";

export type MetaOrderByInput = "id_ASC" | "id_DESC" | "abbr_ASC" | "abbr_DESC";

export type NoncurricularOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC";

export type RequirementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ClassWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ClassWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  className?: Maybe<String>;
  className_not?: Maybe<String>;
  className_in?: Maybe<String[] | String>;
  className_not_in?: Maybe<String[] | String>;
  className_lt?: Maybe<String>;
  className_lte?: Maybe<String>;
  className_gt?: Maybe<String>;
  className_gte?: Maybe<String>;
  className_contains?: Maybe<String>;
  className_not_contains?: Maybe<String>;
  className_starts_with?: Maybe<String>;
  className_not_starts_with?: Maybe<String>;
  className_ends_with?: Maybe<String>;
  className_not_ends_with?: Maybe<String>;
  degreeTitleYearTerm?: Maybe<TermWhereInput>;
  number?: Maybe<String>;
  number_not?: Maybe<String>;
  number_in?: Maybe<String[] | String>;
  number_not_in?: Maybe<String[] | String>;
  number_lt?: Maybe<String>;
  number_lte?: Maybe<String>;
  number_gt?: Maybe<String>;
  number_gte?: Maybe<String>;
  number_contains?: Maybe<String>;
  number_not_contains?: Maybe<String>;
  number_starts_with?: Maybe<String>;
  number_not_starts_with?: Maybe<String>;
  number_ends_with?: Maybe<String>;
  number_not_ends_with?: Maybe<String>;
  requirement?: Maybe<RequirementWhereInput>;
  sortorder?: Maybe<Int>;
  sortorder_not?: Maybe<Int>;
  sortorder_in?: Maybe<Int[] | Int>;
  sortorder_not_in?: Maybe<Int[] | Int>;
  sortorder_lt?: Maybe<Int>;
  sortorder_lte?: Maybe<Int>;
  sortorder_gt?: Maybe<Int>;
  sortorder_gte?: Maybe<Int>;
  subject?: Maybe<String>;
  subject_not?: Maybe<String>;
  subject_in?: Maybe<String[] | String>;
  subject_not_in?: Maybe<String[] | String>;
  subject_lt?: Maybe<String>;
  subject_lte?: Maybe<String>;
  subject_gt?: Maybe<String>;
  subject_gte?: Maybe<String>;
  subject_contains?: Maybe<String>;
  subject_not_contains?: Maybe<String>;
  subject_starts_with?: Maybe<String>;
  subject_not_starts_with?: Maybe<String>;
  subject_ends_with?: Maybe<String>;
  subject_not_ends_with?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  subsortorder_not?: Maybe<Int>;
  subsortorder_in?: Maybe<Int[] | Int>;
  subsortorder_not_in?: Maybe<Int[] | Int>;
  subsortorder_lt?: Maybe<Int>;
  subsortorder_lte?: Maybe<Int>;
  subsortorder_gt?: Maybe<Int>;
  subsortorder_gte?: Maybe<Int>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<ClassWhereInput[] | ClassWhereInput>;
  OR?: Maybe<ClassWhereInput[] | ClassWhereInput>;
  NOT?: Maybe<ClassWhereInput[] | ClassWhereInput>;
}

export interface TermWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  classes_every?: Maybe<ClassWhereInput>;
  classes_some?: Maybe<ClassWhereInput>;
  classes_none?: Maybe<ClassWhereInput>;
  degreeTitleYear?: Maybe<YearWhereInput>;
  noncurricular?: Maybe<NoncurricularWhereInput>;
  term?: Maybe<Int>;
  term_not?: Maybe<Int>;
  term_in?: Maybe<Int[] | Int>;
  term_not_in?: Maybe<Int[] | Int>;
  term_lt?: Maybe<Int>;
  term_lte?: Maybe<Int>;
  term_gt?: Maybe<Int>;
  term_gte?: Maybe<Int>;
  termName?: Maybe<String>;
  termName_not?: Maybe<String>;
  termName_in?: Maybe<String[] | String>;
  termName_not_in?: Maybe<String[] | String>;
  termName_lt?: Maybe<String>;
  termName_lte?: Maybe<String>;
  termName_gt?: Maybe<String>;
  termName_gte?: Maybe<String>;
  termName_contains?: Maybe<String>;
  termName_not_contains?: Maybe<String>;
  termName_starts_with?: Maybe<String>;
  termName_not_starts_with?: Maybe<String>;
  termName_ends_with?: Maybe<String>;
  termName_not_ends_with?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
  yearTermTitle_not?: Maybe<String>;
  yearTermTitle_in?: Maybe<String[] | String>;
  yearTermTitle_not_in?: Maybe<String[] | String>;
  yearTermTitle_lt?: Maybe<String>;
  yearTermTitle_lte?: Maybe<String>;
  yearTermTitle_gt?: Maybe<String>;
  yearTermTitle_gte?: Maybe<String>;
  yearTermTitle_contains?: Maybe<String>;
  yearTermTitle_not_contains?: Maybe<String>;
  yearTermTitle_starts_with?: Maybe<String>;
  yearTermTitle_not_starts_with?: Maybe<String>;
  yearTermTitle_ends_with?: Maybe<String>;
  yearTermTitle_not_ends_with?: Maybe<String>;
  AND?: Maybe<TermWhereInput[] | TermWhereInput>;
  OR?: Maybe<TermWhereInput[] | TermWhereInput>;
  NOT?: Maybe<TermWhereInput[] | TermWhereInput>;
}

export interface YearWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  degreeTitle?: Maybe<DegreeWhereInput>;
  terms_every?: Maybe<TermWhereInput>;
  terms_some?: Maybe<TermWhereInput>;
  terms_none?: Maybe<TermWhereInput>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  AND?: Maybe<YearWhereInput[] | YearWhereInput>;
  OR?: Maybe<YearWhereInput[] | YearWhereInput>;
  NOT?: Maybe<YearWhereInput[] | YearWhereInput>;
}

export interface DegreeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  heading?: Maybe<String>;
  heading_not?: Maybe<String>;
  heading_in?: Maybe<String[] | String>;
  heading_not_in?: Maybe<String[] | String>;
  heading_lt?: Maybe<String>;
  heading_lte?: Maybe<String>;
  heading_gt?: Maybe<String>;
  heading_gte?: Maybe<String>;
  heading_contains?: Maybe<String>;
  heading_not_contains?: Maybe<String>;
  heading_starts_with?: Maybe<String>;
  heading_not_starts_with?: Maybe<String>;
  heading_ends_with?: Maybe<String>;
  heading_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  pathurl?: Maybe<String>;
  pathurl_not?: Maybe<String>;
  pathurl_in?: Maybe<String[] | String>;
  pathurl_not_in?: Maybe<String[] | String>;
  pathurl_lt?: Maybe<String>;
  pathurl_lte?: Maybe<String>;
  pathurl_gt?: Maybe<String>;
  pathurl_gte?: Maybe<String>;
  pathurl_contains?: Maybe<String>;
  pathurl_not_contains?: Maybe<String>;
  pathurl_starts_with?: Maybe<String>;
  pathurl_not_starts_with?: Maybe<String>;
  pathurl_ends_with?: Maybe<String>;
  pathurl_not_ends_with?: Maybe<String>;
  programTitle?: Maybe<ProgramWhereInput>;
  years_every?: Maybe<YearWhereInput>;
  years_some?: Maybe<YearWhereInput>;
  years_none?: Maybe<YearWhereInput>;
  AND?: Maybe<DegreeWhereInput[] | DegreeWhereInput>;
  OR?: Maybe<DegreeWhereInput[] | DegreeWhereInput>;
  NOT?: Maybe<DegreeWhereInput[] | DegreeWhereInput>;
}

export interface ProgramWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  degrees_every?: Maybe<DegreeWhereInput>;
  degrees_some?: Maybe<DegreeWhereInput>;
  degrees_none?: Maybe<DegreeWhereInput>;
  metaTitle?: Maybe<MetaWhereInput>;
  AND?: Maybe<ProgramWhereInput[] | ProgramWhereInput>;
  OR?: Maybe<ProgramWhereInput[] | ProgramWhereInput>;
  NOT?: Maybe<ProgramWhereInput[] | ProgramWhereInput>;
}

export interface MetaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  programs_every?: Maybe<ProgramWhereInput>;
  programs_some?: Maybe<ProgramWhereInput>;
  programs_none?: Maybe<ProgramWhereInput>;
  abbr?: Maybe<String>;
  abbr_not?: Maybe<String>;
  abbr_in?: Maybe<String[] | String>;
  abbr_not_in?: Maybe<String[] | String>;
  abbr_lt?: Maybe<String>;
  abbr_lte?: Maybe<String>;
  abbr_gt?: Maybe<String>;
  abbr_gte?: Maybe<String>;
  abbr_contains?: Maybe<String>;
  abbr_not_contains?: Maybe<String>;
  abbr_starts_with?: Maybe<String>;
  abbr_not_starts_with?: Maybe<String>;
  abbr_ends_with?: Maybe<String>;
  abbr_not_ends_with?: Maybe<String>;
  AND?: Maybe<MetaWhereInput[] | MetaWhereInput>;
  OR?: Maybe<MetaWhereInput[] | MetaWhereInput>;
  NOT?: Maybe<MetaWhereInput[] | MetaWhereInput>;
}

export interface NoncurricularWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  terms_every?: Maybe<TermWhereInput>;
  terms_some?: Maybe<TermWhereInput>;
  terms_none?: Maybe<TermWhereInput>;
  AND?: Maybe<NoncurricularWhereInput[] | NoncurricularWhereInput>;
  OR?: Maybe<NoncurricularWhereInput[] | NoncurricularWhereInput>;
  NOT?: Maybe<NoncurricularWhereInput[] | NoncurricularWhereInput>;
}

export interface RequirementWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  classes_every?: Maybe<ClassWhereInput>;
  classes_some?: Maybe<ClassWhereInput>;
  classes_none?: Maybe<ClassWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<RequirementWhereInput[] | RequirementWhereInput>;
  OR?: Maybe<RequirementWhereInput[] | RequirementWhereInput>;
  NOT?: Maybe<RequirementWhereInput[] | RequirementWhereInput>;
}

export type DegreeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MetaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NoncurricularWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProgramWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RequirementWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TermWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type YearWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ClassCreateInput {
  className?: Maybe<String>;
  degreeTitleYearTerm?: Maybe<TermCreateOneWithoutClassesInput>;
  number?: Maybe<String>;
  requirement?: Maybe<RequirementCreateOneWithoutClassesInput>;
  sortorder?: Maybe<Int>;
  subject?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface TermCreateOneWithoutClassesInput {
  create?: Maybe<TermCreateWithoutClassesInput>;
  connect?: Maybe<TermWhereUniqueInput>;
}

export interface TermCreateWithoutClassesInput {
  degreeTitleYear?: Maybe<YearCreateOneWithoutTermsInput>;
  noncurricular?: Maybe<NoncurricularCreateOneWithoutTermsInput>;
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface YearCreateOneWithoutTermsInput {
  create?: Maybe<YearCreateWithoutTermsInput>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface YearCreateWithoutTermsInput {
  degreeTitle?: Maybe<DegreeCreateOneWithoutYearsInput>;
  year?: Maybe<Int>;
}

export interface DegreeCreateOneWithoutYearsInput {
  create?: Maybe<DegreeCreateWithoutYearsInput>;
  connect?: Maybe<DegreeWhereUniqueInput>;
}

export interface DegreeCreateWithoutYearsInput {
  description?: Maybe<String>;
  heading?: Maybe<String>;
  icon?: Maybe<String>;
  pathurl?: Maybe<String>;
  programTitle?: Maybe<ProgramCreateOneWithoutDegreesInput>;
}

export interface ProgramCreateOneWithoutDegreesInput {
  create?: Maybe<ProgramCreateWithoutDegreesInput>;
  connect?: Maybe<ProgramWhereUniqueInput>;
}

export interface ProgramCreateWithoutDegreesInput {
  metaTitle?: Maybe<MetaCreateOneWithoutProgramsInput>;
}

export interface MetaCreateOneWithoutProgramsInput {
  create?: Maybe<MetaCreateWithoutProgramsInput>;
  connect?: Maybe<MetaWhereUniqueInput>;
}

export interface MetaCreateWithoutProgramsInput {
  abbr?: Maybe<String>;
}

export interface NoncurricularCreateOneWithoutTermsInput {
  create?: Maybe<NoncurricularCreateWithoutTermsInput>;
  connect?: Maybe<NoncurricularWhereUniqueInput>;
}

export interface NoncurricularCreateWithoutTermsInput {
  description?: Maybe<String>;
}

export interface RequirementCreateOneWithoutClassesInput {
  create?: Maybe<RequirementCreateWithoutClassesInput>;
  connect?: Maybe<RequirementWhereUniqueInput>;
}

export interface RequirementCreateWithoutClassesInput {
  description?: Maybe<String>;
}

export interface ClassUpdateInput {
  className?: Maybe<String>;
  degreeTitleYearTerm?: Maybe<TermUpdateOneWithoutClassesInput>;
  number?: Maybe<String>;
  requirement?: Maybe<RequirementUpdateOneWithoutClassesInput>;
  sortorder?: Maybe<Int>;
  subject?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface TermUpdateOneWithoutClassesInput {
  create?: Maybe<TermCreateWithoutClassesInput>;
  update?: Maybe<TermUpdateWithoutClassesDataInput>;
  upsert?: Maybe<TermUpsertWithoutClassesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TermWhereUniqueInput>;
}

export interface TermUpdateWithoutClassesDataInput {
  degreeTitleYear?: Maybe<YearUpdateOneWithoutTermsInput>;
  noncurricular?: Maybe<NoncurricularUpdateOneWithoutTermsInput>;
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface YearUpdateOneWithoutTermsInput {
  create?: Maybe<YearCreateWithoutTermsInput>;
  update?: Maybe<YearUpdateWithoutTermsDataInput>;
  upsert?: Maybe<YearUpsertWithoutTermsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<YearWhereUniqueInput>;
}

export interface YearUpdateWithoutTermsDataInput {
  degreeTitle?: Maybe<DegreeUpdateOneWithoutYearsInput>;
  year?: Maybe<Int>;
}

export interface DegreeUpdateOneWithoutYearsInput {
  create?: Maybe<DegreeCreateWithoutYearsInput>;
  update?: Maybe<DegreeUpdateWithoutYearsDataInput>;
  upsert?: Maybe<DegreeUpsertWithoutYearsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DegreeWhereUniqueInput>;
}

export interface DegreeUpdateWithoutYearsDataInput {
  description?: Maybe<String>;
  heading?: Maybe<String>;
  icon?: Maybe<String>;
  pathurl?: Maybe<String>;
  programTitle?: Maybe<ProgramUpdateOneWithoutDegreesInput>;
}

export interface ProgramUpdateOneWithoutDegreesInput {
  create?: Maybe<ProgramCreateWithoutDegreesInput>;
  update?: Maybe<ProgramUpdateWithoutDegreesDataInput>;
  upsert?: Maybe<ProgramUpsertWithoutDegreesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProgramWhereUniqueInput>;
}

export interface ProgramUpdateWithoutDegreesDataInput {
  metaTitle?: Maybe<MetaUpdateOneWithoutProgramsInput>;
}

export interface MetaUpdateOneWithoutProgramsInput {
  create?: Maybe<MetaCreateWithoutProgramsInput>;
  update?: Maybe<MetaUpdateWithoutProgramsDataInput>;
  upsert?: Maybe<MetaUpsertWithoutProgramsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MetaWhereUniqueInput>;
}

export interface MetaUpdateWithoutProgramsDataInput {
  abbr?: Maybe<String>;
}

export interface MetaUpsertWithoutProgramsInput {
  update: MetaUpdateWithoutProgramsDataInput;
  create: MetaCreateWithoutProgramsInput;
}

export interface ProgramUpsertWithoutDegreesInput {
  update: ProgramUpdateWithoutDegreesDataInput;
  create: ProgramCreateWithoutDegreesInput;
}

export interface DegreeUpsertWithoutYearsInput {
  update: DegreeUpdateWithoutYearsDataInput;
  create: DegreeCreateWithoutYearsInput;
}

export interface YearUpsertWithoutTermsInput {
  update: YearUpdateWithoutTermsDataInput;
  create: YearCreateWithoutTermsInput;
}

export interface NoncurricularUpdateOneWithoutTermsInput {
  create?: Maybe<NoncurricularCreateWithoutTermsInput>;
  update?: Maybe<NoncurricularUpdateWithoutTermsDataInput>;
  upsert?: Maybe<NoncurricularUpsertWithoutTermsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<NoncurricularWhereUniqueInput>;
}

export interface NoncurricularUpdateWithoutTermsDataInput {
  description?: Maybe<String>;
}

export interface NoncurricularUpsertWithoutTermsInput {
  update: NoncurricularUpdateWithoutTermsDataInput;
  create: NoncurricularCreateWithoutTermsInput;
}

export interface TermUpsertWithoutClassesInput {
  update: TermUpdateWithoutClassesDataInput;
  create: TermCreateWithoutClassesInput;
}

export interface RequirementUpdateOneWithoutClassesInput {
  create?: Maybe<RequirementCreateWithoutClassesInput>;
  update?: Maybe<RequirementUpdateWithoutClassesDataInput>;
  upsert?: Maybe<RequirementUpsertWithoutClassesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RequirementWhereUniqueInput>;
}

export interface RequirementUpdateWithoutClassesDataInput {
  description?: Maybe<String>;
}

export interface RequirementUpsertWithoutClassesInput {
  update: RequirementUpdateWithoutClassesDataInput;
  create: RequirementCreateWithoutClassesInput;
}

export interface ClassUpdateManyMutationInput {
  className?: Maybe<String>;
  number?: Maybe<String>;
  sortorder?: Maybe<Int>;
  subject?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface DegreeCreateInput {
  description?: Maybe<String>;
  heading?: Maybe<String>;
  icon?: Maybe<String>;
  pathurl?: Maybe<String>;
  programTitle?: Maybe<ProgramCreateOneWithoutDegreesInput>;
  years?: Maybe<YearCreateManyWithoutDegreeTitleInput>;
}

export interface YearCreateManyWithoutDegreeTitleInput {
  create?: Maybe<
    YearCreateWithoutDegreeTitleInput[] | YearCreateWithoutDegreeTitleInput
  >;
  connect?: Maybe<YearWhereUniqueInput[] | YearWhereUniqueInput>;
}

export interface YearCreateWithoutDegreeTitleInput {
  terms?: Maybe<TermCreateManyWithoutDegreeTitleYearInput>;
  year?: Maybe<Int>;
}

export interface TermCreateManyWithoutDegreeTitleYearInput {
  create?: Maybe<
    | TermCreateWithoutDegreeTitleYearInput[]
    | TermCreateWithoutDegreeTitleYearInput
  >;
  connect?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
}

export interface TermCreateWithoutDegreeTitleYearInput {
  classes?: Maybe<ClassCreateManyWithoutDegreeTitleYearTermInput>;
  noncurricular?: Maybe<NoncurricularCreateOneWithoutTermsInput>;
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface ClassCreateManyWithoutDegreeTitleYearTermInput {
  create?: Maybe<
    | ClassCreateWithoutDegreeTitleYearTermInput[]
    | ClassCreateWithoutDegreeTitleYearTermInput
  >;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
}

export interface ClassCreateWithoutDegreeTitleYearTermInput {
  className?: Maybe<String>;
  number?: Maybe<String>;
  requirement?: Maybe<RequirementCreateOneWithoutClassesInput>;
  sortorder?: Maybe<Int>;
  subject?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface DegreeUpdateInput {
  description?: Maybe<String>;
  heading?: Maybe<String>;
  icon?: Maybe<String>;
  pathurl?: Maybe<String>;
  programTitle?: Maybe<ProgramUpdateOneWithoutDegreesInput>;
  years?: Maybe<YearUpdateManyWithoutDegreeTitleInput>;
}

export interface YearUpdateManyWithoutDegreeTitleInput {
  create?: Maybe<
    YearCreateWithoutDegreeTitleInput[] | YearCreateWithoutDegreeTitleInput
  >;
  delete?: Maybe<YearWhereUniqueInput[] | YearWhereUniqueInput>;
  connect?: Maybe<YearWhereUniqueInput[] | YearWhereUniqueInput>;
  set?: Maybe<YearWhereUniqueInput[] | YearWhereUniqueInput>;
  disconnect?: Maybe<YearWhereUniqueInput[] | YearWhereUniqueInput>;
  update?: Maybe<
    | YearUpdateWithWhereUniqueWithoutDegreeTitleInput[]
    | YearUpdateWithWhereUniqueWithoutDegreeTitleInput
  >;
  upsert?: Maybe<
    | YearUpsertWithWhereUniqueWithoutDegreeTitleInput[]
    | YearUpsertWithWhereUniqueWithoutDegreeTitleInput
  >;
  deleteMany?: Maybe<YearScalarWhereInput[] | YearScalarWhereInput>;
  updateMany?: Maybe<
    YearUpdateManyWithWhereNestedInput[] | YearUpdateManyWithWhereNestedInput
  >;
}

export interface YearUpdateWithWhereUniqueWithoutDegreeTitleInput {
  where: YearWhereUniqueInput;
  data: YearUpdateWithoutDegreeTitleDataInput;
}

export interface YearUpdateWithoutDegreeTitleDataInput {
  terms?: Maybe<TermUpdateManyWithoutDegreeTitleYearInput>;
  year?: Maybe<Int>;
}

export interface TermUpdateManyWithoutDegreeTitleYearInput {
  create?: Maybe<
    | TermCreateWithoutDegreeTitleYearInput[]
    | TermCreateWithoutDegreeTitleYearInput
  >;
  delete?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
  connect?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
  set?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
  disconnect?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
  update?: Maybe<
    | TermUpdateWithWhereUniqueWithoutDegreeTitleYearInput[]
    | TermUpdateWithWhereUniqueWithoutDegreeTitleYearInput
  >;
  upsert?: Maybe<
    | TermUpsertWithWhereUniqueWithoutDegreeTitleYearInput[]
    | TermUpsertWithWhereUniqueWithoutDegreeTitleYearInput
  >;
  deleteMany?: Maybe<TermScalarWhereInput[] | TermScalarWhereInput>;
  updateMany?: Maybe<
    TermUpdateManyWithWhereNestedInput[] | TermUpdateManyWithWhereNestedInput
  >;
}

export interface TermUpdateWithWhereUniqueWithoutDegreeTitleYearInput {
  where: TermWhereUniqueInput;
  data: TermUpdateWithoutDegreeTitleYearDataInput;
}

export interface TermUpdateWithoutDegreeTitleYearDataInput {
  classes?: Maybe<ClassUpdateManyWithoutDegreeTitleYearTermInput>;
  noncurricular?: Maybe<NoncurricularUpdateOneWithoutTermsInput>;
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface ClassUpdateManyWithoutDegreeTitleYearTermInput {
  create?: Maybe<
    | ClassCreateWithoutDegreeTitleYearTermInput[]
    | ClassCreateWithoutDegreeTitleYearTermInput
  >;
  delete?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  set?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  disconnect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  update?: Maybe<
    | ClassUpdateWithWhereUniqueWithoutDegreeTitleYearTermInput[]
    | ClassUpdateWithWhereUniqueWithoutDegreeTitleYearTermInput
  >;
  upsert?: Maybe<
    | ClassUpsertWithWhereUniqueWithoutDegreeTitleYearTermInput[]
    | ClassUpsertWithWhereUniqueWithoutDegreeTitleYearTermInput
  >;
  deleteMany?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  updateMany?: Maybe<
    ClassUpdateManyWithWhereNestedInput[] | ClassUpdateManyWithWhereNestedInput
  >;
}

export interface ClassUpdateWithWhereUniqueWithoutDegreeTitleYearTermInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutDegreeTitleYearTermDataInput;
}

export interface ClassUpdateWithoutDegreeTitleYearTermDataInput {
  className?: Maybe<String>;
  number?: Maybe<String>;
  requirement?: Maybe<RequirementUpdateOneWithoutClassesInput>;
  sortorder?: Maybe<Int>;
  subject?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface ClassUpsertWithWhereUniqueWithoutDegreeTitleYearTermInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutDegreeTitleYearTermDataInput;
  create: ClassCreateWithoutDegreeTitleYearTermInput;
}

export interface ClassScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  className?: Maybe<String>;
  className_not?: Maybe<String>;
  className_in?: Maybe<String[] | String>;
  className_not_in?: Maybe<String[] | String>;
  className_lt?: Maybe<String>;
  className_lte?: Maybe<String>;
  className_gt?: Maybe<String>;
  className_gte?: Maybe<String>;
  className_contains?: Maybe<String>;
  className_not_contains?: Maybe<String>;
  className_starts_with?: Maybe<String>;
  className_not_starts_with?: Maybe<String>;
  className_ends_with?: Maybe<String>;
  className_not_ends_with?: Maybe<String>;
  number?: Maybe<String>;
  number_not?: Maybe<String>;
  number_in?: Maybe<String[] | String>;
  number_not_in?: Maybe<String[] | String>;
  number_lt?: Maybe<String>;
  number_lte?: Maybe<String>;
  number_gt?: Maybe<String>;
  number_gte?: Maybe<String>;
  number_contains?: Maybe<String>;
  number_not_contains?: Maybe<String>;
  number_starts_with?: Maybe<String>;
  number_not_starts_with?: Maybe<String>;
  number_ends_with?: Maybe<String>;
  number_not_ends_with?: Maybe<String>;
  sortorder?: Maybe<Int>;
  sortorder_not?: Maybe<Int>;
  sortorder_in?: Maybe<Int[] | Int>;
  sortorder_not_in?: Maybe<Int[] | Int>;
  sortorder_lt?: Maybe<Int>;
  sortorder_lte?: Maybe<Int>;
  sortorder_gt?: Maybe<Int>;
  sortorder_gte?: Maybe<Int>;
  subject?: Maybe<String>;
  subject_not?: Maybe<String>;
  subject_in?: Maybe<String[] | String>;
  subject_not_in?: Maybe<String[] | String>;
  subject_lt?: Maybe<String>;
  subject_lte?: Maybe<String>;
  subject_gt?: Maybe<String>;
  subject_gte?: Maybe<String>;
  subject_contains?: Maybe<String>;
  subject_not_contains?: Maybe<String>;
  subject_starts_with?: Maybe<String>;
  subject_not_starts_with?: Maybe<String>;
  subject_ends_with?: Maybe<String>;
  subject_not_ends_with?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  subsortorder_not?: Maybe<Int>;
  subsortorder_in?: Maybe<Int[] | Int>;
  subsortorder_not_in?: Maybe<Int[] | Int>;
  subsortorder_lt?: Maybe<Int>;
  subsortorder_lte?: Maybe<Int>;
  subsortorder_gt?: Maybe<Int>;
  subsortorder_gte?: Maybe<Int>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  OR?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  NOT?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
}

export interface ClassUpdateManyWithWhereNestedInput {
  where: ClassScalarWhereInput;
  data: ClassUpdateManyDataInput;
}

export interface ClassUpdateManyDataInput {
  className?: Maybe<String>;
  number?: Maybe<String>;
  sortorder?: Maybe<Int>;
  subject?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface TermUpsertWithWhereUniqueWithoutDegreeTitleYearInput {
  where: TermWhereUniqueInput;
  update: TermUpdateWithoutDegreeTitleYearDataInput;
  create: TermCreateWithoutDegreeTitleYearInput;
}

export interface TermScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  term?: Maybe<Int>;
  term_not?: Maybe<Int>;
  term_in?: Maybe<Int[] | Int>;
  term_not_in?: Maybe<Int[] | Int>;
  term_lt?: Maybe<Int>;
  term_lte?: Maybe<Int>;
  term_gt?: Maybe<Int>;
  term_gte?: Maybe<Int>;
  termName?: Maybe<String>;
  termName_not?: Maybe<String>;
  termName_in?: Maybe<String[] | String>;
  termName_not_in?: Maybe<String[] | String>;
  termName_lt?: Maybe<String>;
  termName_lte?: Maybe<String>;
  termName_gt?: Maybe<String>;
  termName_gte?: Maybe<String>;
  termName_contains?: Maybe<String>;
  termName_not_contains?: Maybe<String>;
  termName_starts_with?: Maybe<String>;
  termName_not_starts_with?: Maybe<String>;
  termName_ends_with?: Maybe<String>;
  termName_not_ends_with?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
  yearTermTitle_not?: Maybe<String>;
  yearTermTitle_in?: Maybe<String[] | String>;
  yearTermTitle_not_in?: Maybe<String[] | String>;
  yearTermTitle_lt?: Maybe<String>;
  yearTermTitle_lte?: Maybe<String>;
  yearTermTitle_gt?: Maybe<String>;
  yearTermTitle_gte?: Maybe<String>;
  yearTermTitle_contains?: Maybe<String>;
  yearTermTitle_not_contains?: Maybe<String>;
  yearTermTitle_starts_with?: Maybe<String>;
  yearTermTitle_not_starts_with?: Maybe<String>;
  yearTermTitle_ends_with?: Maybe<String>;
  yearTermTitle_not_ends_with?: Maybe<String>;
  AND?: Maybe<TermScalarWhereInput[] | TermScalarWhereInput>;
  OR?: Maybe<TermScalarWhereInput[] | TermScalarWhereInput>;
  NOT?: Maybe<TermScalarWhereInput[] | TermScalarWhereInput>;
}

export interface TermUpdateManyWithWhereNestedInput {
  where: TermScalarWhereInput;
  data: TermUpdateManyDataInput;
}

export interface TermUpdateManyDataInput {
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface YearUpsertWithWhereUniqueWithoutDegreeTitleInput {
  where: YearWhereUniqueInput;
  update: YearUpdateWithoutDegreeTitleDataInput;
  create: YearCreateWithoutDegreeTitleInput;
}

export interface YearScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  AND?: Maybe<YearScalarWhereInput[] | YearScalarWhereInput>;
  OR?: Maybe<YearScalarWhereInput[] | YearScalarWhereInput>;
  NOT?: Maybe<YearScalarWhereInput[] | YearScalarWhereInput>;
}

export interface YearUpdateManyWithWhereNestedInput {
  where: YearScalarWhereInput;
  data: YearUpdateManyDataInput;
}

export interface YearUpdateManyDataInput {
  year?: Maybe<Int>;
}

export interface DegreeUpdateManyMutationInput {
  description?: Maybe<String>;
  heading?: Maybe<String>;
  icon?: Maybe<String>;
  pathurl?: Maybe<String>;
}

export interface MetaCreateInput {
  programs?: Maybe<ProgramCreateManyWithoutMetaTitleInput>;
  abbr?: Maybe<String>;
}

export interface ProgramCreateManyWithoutMetaTitleInput {
  create?: Maybe<
    ProgramCreateWithoutMetaTitleInput[] | ProgramCreateWithoutMetaTitleInput
  >;
  connect?: Maybe<ProgramWhereUniqueInput[] | ProgramWhereUniqueInput>;
}

export interface ProgramCreateWithoutMetaTitleInput {
  degrees?: Maybe<DegreeCreateManyWithoutProgramTitleInput>;
}

export interface DegreeCreateManyWithoutProgramTitleInput {
  create?: Maybe<
    | DegreeCreateWithoutProgramTitleInput[]
    | DegreeCreateWithoutProgramTitleInput
  >;
  connect?: Maybe<DegreeWhereUniqueInput[] | DegreeWhereUniqueInput>;
}

export interface DegreeCreateWithoutProgramTitleInput {
  description?: Maybe<String>;
  heading?: Maybe<String>;
  icon?: Maybe<String>;
  pathurl?: Maybe<String>;
  years?: Maybe<YearCreateManyWithoutDegreeTitleInput>;
}

export interface MetaUpdateInput {
  programs?: Maybe<ProgramUpdateManyWithoutMetaTitleInput>;
  abbr?: Maybe<String>;
}

export interface ProgramUpdateManyWithoutMetaTitleInput {
  create?: Maybe<
    ProgramCreateWithoutMetaTitleInput[] | ProgramCreateWithoutMetaTitleInput
  >;
  delete?: Maybe<ProgramWhereUniqueInput[] | ProgramWhereUniqueInput>;
  connect?: Maybe<ProgramWhereUniqueInput[] | ProgramWhereUniqueInput>;
  set?: Maybe<ProgramWhereUniqueInput[] | ProgramWhereUniqueInput>;
  disconnect?: Maybe<ProgramWhereUniqueInput[] | ProgramWhereUniqueInput>;
  update?: Maybe<
    | ProgramUpdateWithWhereUniqueWithoutMetaTitleInput[]
    | ProgramUpdateWithWhereUniqueWithoutMetaTitleInput
  >;
  upsert?: Maybe<
    | ProgramUpsertWithWhereUniqueWithoutMetaTitleInput[]
    | ProgramUpsertWithWhereUniqueWithoutMetaTitleInput
  >;
  deleteMany?: Maybe<ProgramScalarWhereInput[] | ProgramScalarWhereInput>;
}

export interface ProgramUpdateWithWhereUniqueWithoutMetaTitleInput {
  where: ProgramWhereUniqueInput;
  data: ProgramUpdateWithoutMetaTitleDataInput;
}

export interface ProgramUpdateWithoutMetaTitleDataInput {
  degrees?: Maybe<DegreeUpdateManyWithoutProgramTitleInput>;
}

export interface DegreeUpdateManyWithoutProgramTitleInput {
  create?: Maybe<
    | DegreeCreateWithoutProgramTitleInput[]
    | DegreeCreateWithoutProgramTitleInput
  >;
  delete?: Maybe<DegreeWhereUniqueInput[] | DegreeWhereUniqueInput>;
  connect?: Maybe<DegreeWhereUniqueInput[] | DegreeWhereUniqueInput>;
  set?: Maybe<DegreeWhereUniqueInput[] | DegreeWhereUniqueInput>;
  disconnect?: Maybe<DegreeWhereUniqueInput[] | DegreeWhereUniqueInput>;
  update?: Maybe<
    | DegreeUpdateWithWhereUniqueWithoutProgramTitleInput[]
    | DegreeUpdateWithWhereUniqueWithoutProgramTitleInput
  >;
  upsert?: Maybe<
    | DegreeUpsertWithWhereUniqueWithoutProgramTitleInput[]
    | DegreeUpsertWithWhereUniqueWithoutProgramTitleInput
  >;
  deleteMany?: Maybe<DegreeScalarWhereInput[] | DegreeScalarWhereInput>;
  updateMany?: Maybe<
    | DegreeUpdateManyWithWhereNestedInput[]
    | DegreeUpdateManyWithWhereNestedInput
  >;
}

export interface DegreeUpdateWithWhereUniqueWithoutProgramTitleInput {
  where: DegreeWhereUniqueInput;
  data: DegreeUpdateWithoutProgramTitleDataInput;
}

export interface DegreeUpdateWithoutProgramTitleDataInput {
  description?: Maybe<String>;
  heading?: Maybe<String>;
  icon?: Maybe<String>;
  pathurl?: Maybe<String>;
  years?: Maybe<YearUpdateManyWithoutDegreeTitleInput>;
}

export interface DegreeUpsertWithWhereUniqueWithoutProgramTitleInput {
  where: DegreeWhereUniqueInput;
  update: DegreeUpdateWithoutProgramTitleDataInput;
  create: DegreeCreateWithoutProgramTitleInput;
}

export interface DegreeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  heading?: Maybe<String>;
  heading_not?: Maybe<String>;
  heading_in?: Maybe<String[] | String>;
  heading_not_in?: Maybe<String[] | String>;
  heading_lt?: Maybe<String>;
  heading_lte?: Maybe<String>;
  heading_gt?: Maybe<String>;
  heading_gte?: Maybe<String>;
  heading_contains?: Maybe<String>;
  heading_not_contains?: Maybe<String>;
  heading_starts_with?: Maybe<String>;
  heading_not_starts_with?: Maybe<String>;
  heading_ends_with?: Maybe<String>;
  heading_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  pathurl?: Maybe<String>;
  pathurl_not?: Maybe<String>;
  pathurl_in?: Maybe<String[] | String>;
  pathurl_not_in?: Maybe<String[] | String>;
  pathurl_lt?: Maybe<String>;
  pathurl_lte?: Maybe<String>;
  pathurl_gt?: Maybe<String>;
  pathurl_gte?: Maybe<String>;
  pathurl_contains?: Maybe<String>;
  pathurl_not_contains?: Maybe<String>;
  pathurl_starts_with?: Maybe<String>;
  pathurl_not_starts_with?: Maybe<String>;
  pathurl_ends_with?: Maybe<String>;
  pathurl_not_ends_with?: Maybe<String>;
  AND?: Maybe<DegreeScalarWhereInput[] | DegreeScalarWhereInput>;
  OR?: Maybe<DegreeScalarWhereInput[] | DegreeScalarWhereInput>;
  NOT?: Maybe<DegreeScalarWhereInput[] | DegreeScalarWhereInput>;
}

export interface DegreeUpdateManyWithWhereNestedInput {
  where: DegreeScalarWhereInput;
  data: DegreeUpdateManyDataInput;
}

export interface DegreeUpdateManyDataInput {
  description?: Maybe<String>;
  heading?: Maybe<String>;
  icon?: Maybe<String>;
  pathurl?: Maybe<String>;
}

export interface ProgramUpsertWithWhereUniqueWithoutMetaTitleInput {
  where: ProgramWhereUniqueInput;
  update: ProgramUpdateWithoutMetaTitleDataInput;
  create: ProgramCreateWithoutMetaTitleInput;
}

export interface ProgramScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<ProgramScalarWhereInput[] | ProgramScalarWhereInput>;
  OR?: Maybe<ProgramScalarWhereInput[] | ProgramScalarWhereInput>;
  NOT?: Maybe<ProgramScalarWhereInput[] | ProgramScalarWhereInput>;
}

export interface MetaUpdateManyMutationInput {
  abbr?: Maybe<String>;
}

export interface NoncurricularCreateInput {
  description?: Maybe<String>;
  terms?: Maybe<TermCreateManyWithoutNoncurricularInput>;
}

export interface TermCreateManyWithoutNoncurricularInput {
  create?: Maybe<
    TermCreateWithoutNoncurricularInput[] | TermCreateWithoutNoncurricularInput
  >;
  connect?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
}

export interface TermCreateWithoutNoncurricularInput {
  classes?: Maybe<ClassCreateManyWithoutDegreeTitleYearTermInput>;
  degreeTitleYear?: Maybe<YearCreateOneWithoutTermsInput>;
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface NoncurricularUpdateInput {
  description?: Maybe<String>;
  terms?: Maybe<TermUpdateManyWithoutNoncurricularInput>;
}

export interface TermUpdateManyWithoutNoncurricularInput {
  create?: Maybe<
    TermCreateWithoutNoncurricularInput[] | TermCreateWithoutNoncurricularInput
  >;
  delete?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
  connect?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
  set?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
  disconnect?: Maybe<TermWhereUniqueInput[] | TermWhereUniqueInput>;
  update?: Maybe<
    | TermUpdateWithWhereUniqueWithoutNoncurricularInput[]
    | TermUpdateWithWhereUniqueWithoutNoncurricularInput
  >;
  upsert?: Maybe<
    | TermUpsertWithWhereUniqueWithoutNoncurricularInput[]
    | TermUpsertWithWhereUniqueWithoutNoncurricularInput
  >;
  deleteMany?: Maybe<TermScalarWhereInput[] | TermScalarWhereInput>;
  updateMany?: Maybe<
    TermUpdateManyWithWhereNestedInput[] | TermUpdateManyWithWhereNestedInput
  >;
}

export interface TermUpdateWithWhereUniqueWithoutNoncurricularInput {
  where: TermWhereUniqueInput;
  data: TermUpdateWithoutNoncurricularDataInput;
}

export interface TermUpdateWithoutNoncurricularDataInput {
  classes?: Maybe<ClassUpdateManyWithoutDegreeTitleYearTermInput>;
  degreeTitleYear?: Maybe<YearUpdateOneWithoutTermsInput>;
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface TermUpsertWithWhereUniqueWithoutNoncurricularInput {
  where: TermWhereUniqueInput;
  update: TermUpdateWithoutNoncurricularDataInput;
  create: TermCreateWithoutNoncurricularInput;
}

export interface NoncurricularUpdateManyMutationInput {
  description?: Maybe<String>;
}

export interface ProgramCreateInput {
  degrees?: Maybe<DegreeCreateManyWithoutProgramTitleInput>;
  metaTitle?: Maybe<MetaCreateOneWithoutProgramsInput>;
}

export interface ProgramUpdateInput {
  degrees?: Maybe<DegreeUpdateManyWithoutProgramTitleInput>;
  metaTitle?: Maybe<MetaUpdateOneWithoutProgramsInput>;
}

export interface RequirementCreateInput {
  classes?: Maybe<ClassCreateManyWithoutRequirementInput>;
  description?: Maybe<String>;
}

export interface ClassCreateManyWithoutRequirementInput {
  create?: Maybe<
    ClassCreateWithoutRequirementInput[] | ClassCreateWithoutRequirementInput
  >;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
}

export interface ClassCreateWithoutRequirementInput {
  className?: Maybe<String>;
  degreeTitleYearTerm?: Maybe<TermCreateOneWithoutClassesInput>;
  number?: Maybe<String>;
  sortorder?: Maybe<Int>;
  subject?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface RequirementUpdateInput {
  classes?: Maybe<ClassUpdateManyWithoutRequirementInput>;
  description?: Maybe<String>;
}

export interface ClassUpdateManyWithoutRequirementInput {
  create?: Maybe<
    ClassCreateWithoutRequirementInput[] | ClassCreateWithoutRequirementInput
  >;
  delete?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  set?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  disconnect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  update?: Maybe<
    | ClassUpdateWithWhereUniqueWithoutRequirementInput[]
    | ClassUpdateWithWhereUniqueWithoutRequirementInput
  >;
  upsert?: Maybe<
    | ClassUpsertWithWhereUniqueWithoutRequirementInput[]
    | ClassUpsertWithWhereUniqueWithoutRequirementInput
  >;
  deleteMany?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  updateMany?: Maybe<
    ClassUpdateManyWithWhereNestedInput[] | ClassUpdateManyWithWhereNestedInput
  >;
}

export interface ClassUpdateWithWhereUniqueWithoutRequirementInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutRequirementDataInput;
}

export interface ClassUpdateWithoutRequirementDataInput {
  className?: Maybe<String>;
  degreeTitleYearTerm?: Maybe<TermUpdateOneWithoutClassesInput>;
  number?: Maybe<String>;
  sortorder?: Maybe<Int>;
  subject?: Maybe<String>;
  subsortorder?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface ClassUpsertWithWhereUniqueWithoutRequirementInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutRequirementDataInput;
  create: ClassCreateWithoutRequirementInput;
}

export interface RequirementUpdateManyMutationInput {
  description?: Maybe<String>;
}

export interface TermCreateInput {
  classes?: Maybe<ClassCreateManyWithoutDegreeTitleYearTermInput>;
  degreeTitleYear?: Maybe<YearCreateOneWithoutTermsInput>;
  noncurricular?: Maybe<NoncurricularCreateOneWithoutTermsInput>;
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface TermUpdateInput {
  classes?: Maybe<ClassUpdateManyWithoutDegreeTitleYearTermInput>;
  degreeTitleYear?: Maybe<YearUpdateOneWithoutTermsInput>;
  noncurricular?: Maybe<NoncurricularUpdateOneWithoutTermsInput>;
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface TermUpdateManyMutationInput {
  term?: Maybe<Int>;
  termName?: Maybe<String>;
  yearTermTitle?: Maybe<String>;
}

export interface YearCreateInput {
  degreeTitle?: Maybe<DegreeCreateOneWithoutYearsInput>;
  terms?: Maybe<TermCreateManyWithoutDegreeTitleYearInput>;
  year?: Maybe<Int>;
}

export interface YearUpdateInput {
  degreeTitle?: Maybe<DegreeUpdateOneWithoutYearsInput>;
  terms?: Maybe<TermUpdateManyWithoutDegreeTitleYearInput>;
  year?: Maybe<Int>;
}

export interface YearUpdateManyMutationInput {
  year?: Maybe<Int>;
}

export interface ClassSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClassWhereInput>;
  AND?: Maybe<ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput>;
  OR?: Maybe<ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput>;
  NOT?: Maybe<ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput>;
}

export interface DegreeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DegreeWhereInput>;
  AND?: Maybe<DegreeSubscriptionWhereInput[] | DegreeSubscriptionWhereInput>;
  OR?: Maybe<DegreeSubscriptionWhereInput[] | DegreeSubscriptionWhereInput>;
  NOT?: Maybe<DegreeSubscriptionWhereInput[] | DegreeSubscriptionWhereInput>;
}

export interface MetaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MetaWhereInput>;
  AND?: Maybe<MetaSubscriptionWhereInput[] | MetaSubscriptionWhereInput>;
  OR?: Maybe<MetaSubscriptionWhereInput[] | MetaSubscriptionWhereInput>;
  NOT?: Maybe<MetaSubscriptionWhereInput[] | MetaSubscriptionWhereInput>;
}

export interface NoncurricularSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NoncurricularWhereInput>;
  AND?: Maybe<
    NoncurricularSubscriptionWhereInput[] | NoncurricularSubscriptionWhereInput
  >;
  OR?: Maybe<
    NoncurricularSubscriptionWhereInput[] | NoncurricularSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NoncurricularSubscriptionWhereInput[] | NoncurricularSubscriptionWhereInput
  >;
}

export interface ProgramSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProgramWhereInput>;
  AND?: Maybe<ProgramSubscriptionWhereInput[] | ProgramSubscriptionWhereInput>;
  OR?: Maybe<ProgramSubscriptionWhereInput[] | ProgramSubscriptionWhereInput>;
  NOT?: Maybe<ProgramSubscriptionWhereInput[] | ProgramSubscriptionWhereInput>;
}

export interface RequirementSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RequirementWhereInput>;
  AND?: Maybe<
    RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput
  >;
  OR?: Maybe<
    RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput
  >;
}

export interface TermSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TermWhereInput>;
  AND?: Maybe<TermSubscriptionWhereInput[] | TermSubscriptionWhereInput>;
  OR?: Maybe<TermSubscriptionWhereInput[] | TermSubscriptionWhereInput>;
  NOT?: Maybe<TermSubscriptionWhereInput[] | TermSubscriptionWhereInput>;
}

export interface YearSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<YearWhereInput>;
  AND?: Maybe<YearSubscriptionWhereInput[] | YearSubscriptionWhereInput>;
  OR?: Maybe<YearSubscriptionWhereInput[] | YearSubscriptionWhereInput>;
  NOT?: Maybe<YearSubscriptionWhereInput[] | YearSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Class {
  id: Int;
  className?: String;
  number?: String;
  sortorder?: Int;
  subject?: String;
  subsortorder?: Int;
  url?: String;
}

export interface ClassPromise extends Promise<Class>, Fragmentable {
  id: () => Promise<Int>;
  className: () => Promise<String>;
  degreeTitleYearTerm: <T = TermPromise>() => T;
  number: () => Promise<String>;
  requirement: <T = RequirementPromise>() => T;
  sortorder: () => Promise<Int>;
  subject: () => Promise<String>;
  subsortorder: () => Promise<Int>;
  url: () => Promise<String>;
}

export interface ClassSubscription
  extends Promise<AsyncIterator<Class>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  className: () => Promise<AsyncIterator<String>>;
  degreeTitleYearTerm: <T = TermSubscription>() => T;
  number: () => Promise<AsyncIterator<String>>;
  requirement: <T = RequirementSubscription>() => T;
  sortorder: () => Promise<AsyncIterator<Int>>;
  subject: () => Promise<AsyncIterator<String>>;
  subsortorder: () => Promise<AsyncIterator<Int>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ClassNullablePromise
  extends Promise<Class | null>,
    Fragmentable {
  id: () => Promise<Int>;
  className: () => Promise<String>;
  degreeTitleYearTerm: <T = TermPromise>() => T;
  number: () => Promise<String>;
  requirement: <T = RequirementPromise>() => T;
  sortorder: () => Promise<Int>;
  subject: () => Promise<String>;
  subsortorder: () => Promise<Int>;
  url: () => Promise<String>;
}

export interface Term {
  id: ID_Output;
  term?: Int;
  termName?: String;
  yearTermTitle?: String;
}

export interface TermPromise extends Promise<Term>, Fragmentable {
  id: () => Promise<ID_Output>;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  degreeTitleYear: <T = YearPromise>() => T;
  noncurricular: <T = NoncurricularPromise>() => T;
  term: () => Promise<Int>;
  termName: () => Promise<String>;
  yearTermTitle: () => Promise<String>;
}

export interface TermSubscription
  extends Promise<AsyncIterator<Term>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  degreeTitleYear: <T = YearSubscription>() => T;
  noncurricular: <T = NoncurricularSubscription>() => T;
  term: () => Promise<AsyncIterator<Int>>;
  termName: () => Promise<AsyncIterator<String>>;
  yearTermTitle: () => Promise<AsyncIterator<String>>;
}

export interface TermNullablePromise
  extends Promise<Term | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  degreeTitleYear: <T = YearPromise>() => T;
  noncurricular: <T = NoncurricularPromise>() => T;
  term: () => Promise<Int>;
  termName: () => Promise<String>;
  yearTermTitle: () => Promise<String>;
}

export interface Year {
  id: ID_Output;
  year?: Int;
}

export interface YearPromise extends Promise<Year>, Fragmentable {
  id: () => Promise<ID_Output>;
  degreeTitle: <T = DegreePromise>() => T;
  terms: <T = FragmentableArray<Term>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  year: () => Promise<Int>;
}

export interface YearSubscription
  extends Promise<AsyncIterator<Year>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  degreeTitle: <T = DegreeSubscription>() => T;
  terms: <T = Promise<AsyncIterator<TermSubscription>>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  year: () => Promise<AsyncIterator<Int>>;
}

export interface YearNullablePromise
  extends Promise<Year | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  degreeTitle: <T = DegreePromise>() => T;
  terms: <T = FragmentableArray<Term>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  year: () => Promise<Int>;
}

export interface Degree {
  id: ID_Output;
  description?: String;
  heading?: String;
  icon?: String;
  pathurl?: String;
}

export interface DegreePromise extends Promise<Degree>, Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  heading: () => Promise<String>;
  icon: () => Promise<String>;
  pathurl: () => Promise<String>;
  programTitle: <T = ProgramPromise>() => T;
  years: <T = FragmentableArray<Year>>(args?: {
    where?: YearWhereInput;
    orderBy?: YearOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DegreeSubscription
  extends Promise<AsyncIterator<Degree>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  heading: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  pathurl: () => Promise<AsyncIterator<String>>;
  programTitle: <T = ProgramSubscription>() => T;
  years: <T = Promise<AsyncIterator<YearSubscription>>>(args?: {
    where?: YearWhereInput;
    orderBy?: YearOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DegreeNullablePromise
  extends Promise<Degree | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  heading: () => Promise<String>;
  icon: () => Promise<String>;
  pathurl: () => Promise<String>;
  programTitle: <T = ProgramPromise>() => T;
  years: <T = FragmentableArray<Year>>(args?: {
    where?: YearWhereInput;
    orderBy?: YearOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Program {
  id: ID_Output;
}

export interface ProgramPromise extends Promise<Program>, Fragmentable {
  id: () => Promise<ID_Output>;
  degrees: <T = FragmentableArray<Degree>>(args?: {
    where?: DegreeWhereInput;
    orderBy?: DegreeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  metaTitle: <T = MetaPromise>() => T;
}

export interface ProgramSubscription
  extends Promise<AsyncIterator<Program>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  degrees: <T = Promise<AsyncIterator<DegreeSubscription>>>(args?: {
    where?: DegreeWhereInput;
    orderBy?: DegreeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  metaTitle: <T = MetaSubscription>() => T;
}

export interface ProgramNullablePromise
  extends Promise<Program | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  degrees: <T = FragmentableArray<Degree>>(args?: {
    where?: DegreeWhereInput;
    orderBy?: DegreeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  metaTitle: <T = MetaPromise>() => T;
}

export interface Meta {
  id: ID_Output;
  abbr?: String;
}

export interface MetaPromise extends Promise<Meta>, Fragmentable {
  id: () => Promise<ID_Output>;
  programs: <T = FragmentableArray<Program>>(args?: {
    where?: ProgramWhereInput;
    orderBy?: ProgramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  abbr: () => Promise<String>;
}

export interface MetaSubscription
  extends Promise<AsyncIterator<Meta>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  programs: <T = Promise<AsyncIterator<ProgramSubscription>>>(args?: {
    where?: ProgramWhereInput;
    orderBy?: ProgramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  abbr: () => Promise<AsyncIterator<String>>;
}

export interface MetaNullablePromise
  extends Promise<Meta | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  programs: <T = FragmentableArray<Program>>(args?: {
    where?: ProgramWhereInput;
    orderBy?: ProgramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  abbr: () => Promise<String>;
}

export interface Noncurricular {
  id: ID_Output;
  description?: String;
}

export interface NoncurricularPromise
  extends Promise<Noncurricular>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  terms: <T = FragmentableArray<Term>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NoncurricularSubscription
  extends Promise<AsyncIterator<Noncurricular>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  terms: <T = Promise<AsyncIterator<TermSubscription>>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NoncurricularNullablePromise
  extends Promise<Noncurricular | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  terms: <T = FragmentableArray<Term>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Requirement {
  id: ID_Output;
  description?: String;
}

export interface RequirementPromise extends Promise<Requirement>, Fragmentable {
  id: () => Promise<ID_Output>;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  description: () => Promise<String>;
}

export interface RequirementSubscription
  extends Promise<AsyncIterator<Requirement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  description: () => Promise<AsyncIterator<String>>;
}

export interface RequirementNullablePromise
  extends Promise<Requirement | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  description: () => Promise<String>;
}

export interface ClassConnection {
  pageInfo: PageInfo;
  edges: ClassEdge[];
}

export interface ClassConnectionPromise
  extends Promise<ClassConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassEdge>>() => T;
  aggregate: <T = AggregateClassPromise>() => T;
}

export interface ClassConnectionSubscription
  extends Promise<AsyncIterator<ClassConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ClassEdge {
  node: Class;
  cursor: String;
}

export interface ClassEdgePromise extends Promise<ClassEdge>, Fragmentable {
  node: <T = ClassPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassEdgeSubscription
  extends Promise<AsyncIterator<ClassEdge>>,
    Fragmentable {
  node: <T = ClassSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClass {
  count: Int;
}

export interface AggregateClassPromise
  extends Promise<AggregateClass>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassSubscription
  extends Promise<AsyncIterator<AggregateClass>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DegreeConnection {
  pageInfo: PageInfo;
  edges: DegreeEdge[];
}

export interface DegreeConnectionPromise
  extends Promise<DegreeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DegreeEdge>>() => T;
  aggregate: <T = AggregateDegreePromise>() => T;
}

export interface DegreeConnectionSubscription
  extends Promise<AsyncIterator<DegreeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DegreeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDegreeSubscription>() => T;
}

export interface DegreeEdge {
  node: Degree;
  cursor: String;
}

export interface DegreeEdgePromise extends Promise<DegreeEdge>, Fragmentable {
  node: <T = DegreePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DegreeEdgeSubscription
  extends Promise<AsyncIterator<DegreeEdge>>,
    Fragmentable {
  node: <T = DegreeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDegree {
  count: Int;
}

export interface AggregateDegreePromise
  extends Promise<AggregateDegree>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDegreeSubscription
  extends Promise<AsyncIterator<AggregateDegree>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MetaConnection {
  pageInfo: PageInfo;
  edges: MetaEdge[];
}

export interface MetaConnectionPromise
  extends Promise<MetaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MetaEdge>>() => T;
  aggregate: <T = AggregateMetaPromise>() => T;
}

export interface MetaConnectionSubscription
  extends Promise<AsyncIterator<MetaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MetaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMetaSubscription>() => T;
}

export interface MetaEdge {
  node: Meta;
  cursor: String;
}

export interface MetaEdgePromise extends Promise<MetaEdge>, Fragmentable {
  node: <T = MetaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MetaEdgeSubscription
  extends Promise<AsyncIterator<MetaEdge>>,
    Fragmentable {
  node: <T = MetaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMeta {
  count: Int;
}

export interface AggregateMetaPromise
  extends Promise<AggregateMeta>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMetaSubscription
  extends Promise<AsyncIterator<AggregateMeta>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NoncurricularConnection {
  pageInfo: PageInfo;
  edges: NoncurricularEdge[];
}

export interface NoncurricularConnectionPromise
  extends Promise<NoncurricularConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NoncurricularEdge>>() => T;
  aggregate: <T = AggregateNoncurricularPromise>() => T;
}

export interface NoncurricularConnectionSubscription
  extends Promise<AsyncIterator<NoncurricularConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NoncurricularEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNoncurricularSubscription>() => T;
}

export interface NoncurricularEdge {
  node: Noncurricular;
  cursor: String;
}

export interface NoncurricularEdgePromise
  extends Promise<NoncurricularEdge>,
    Fragmentable {
  node: <T = NoncurricularPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NoncurricularEdgeSubscription
  extends Promise<AsyncIterator<NoncurricularEdge>>,
    Fragmentable {
  node: <T = NoncurricularSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNoncurricular {
  count: Int;
}

export interface AggregateNoncurricularPromise
  extends Promise<AggregateNoncurricular>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNoncurricularSubscription
  extends Promise<AsyncIterator<AggregateNoncurricular>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProgramConnection {
  pageInfo: PageInfo;
  edges: ProgramEdge[];
}

export interface ProgramConnectionPromise
  extends Promise<ProgramConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProgramEdge>>() => T;
  aggregate: <T = AggregateProgramPromise>() => T;
}

export interface ProgramConnectionSubscription
  extends Promise<AsyncIterator<ProgramConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProgramEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProgramSubscription>() => T;
}

export interface ProgramEdge {
  node: Program;
  cursor: String;
}

export interface ProgramEdgePromise extends Promise<ProgramEdge>, Fragmentable {
  node: <T = ProgramPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProgramEdgeSubscription
  extends Promise<AsyncIterator<ProgramEdge>>,
    Fragmentable {
  node: <T = ProgramSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProgram {
  count: Int;
}

export interface AggregateProgramPromise
  extends Promise<AggregateProgram>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProgramSubscription
  extends Promise<AsyncIterator<AggregateProgram>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RequirementConnection {
  pageInfo: PageInfo;
  edges: RequirementEdge[];
}

export interface RequirementConnectionPromise
  extends Promise<RequirementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RequirementEdge>>() => T;
  aggregate: <T = AggregateRequirementPromise>() => T;
}

export interface RequirementConnectionSubscription
  extends Promise<AsyncIterator<RequirementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RequirementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRequirementSubscription>() => T;
}

export interface RequirementEdge {
  node: Requirement;
  cursor: String;
}

export interface RequirementEdgePromise
  extends Promise<RequirementEdge>,
    Fragmentable {
  node: <T = RequirementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RequirementEdgeSubscription
  extends Promise<AsyncIterator<RequirementEdge>>,
    Fragmentable {
  node: <T = RequirementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRequirement {
  count: Int;
}

export interface AggregateRequirementPromise
  extends Promise<AggregateRequirement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRequirementSubscription
  extends Promise<AsyncIterator<AggregateRequirement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TermConnection {
  pageInfo: PageInfo;
  edges: TermEdge[];
}

export interface TermConnectionPromise
  extends Promise<TermConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TermEdge>>() => T;
  aggregate: <T = AggregateTermPromise>() => T;
}

export interface TermConnectionSubscription
  extends Promise<AsyncIterator<TermConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TermEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTermSubscription>() => T;
}

export interface TermEdge {
  node: Term;
  cursor: String;
}

export interface TermEdgePromise extends Promise<TermEdge>, Fragmentable {
  node: <T = TermPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TermEdgeSubscription
  extends Promise<AsyncIterator<TermEdge>>,
    Fragmentable {
  node: <T = TermSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTerm {
  count: Int;
}

export interface AggregateTermPromise
  extends Promise<AggregateTerm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTermSubscription
  extends Promise<AsyncIterator<AggregateTerm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface YearConnection {
  pageInfo: PageInfo;
  edges: YearEdge[];
}

export interface YearConnectionPromise
  extends Promise<YearConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<YearEdge>>() => T;
  aggregate: <T = AggregateYearPromise>() => T;
}

export interface YearConnectionSubscription
  extends Promise<AsyncIterator<YearConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<YearEdgeSubscription>>>() => T;
  aggregate: <T = AggregateYearSubscription>() => T;
}

export interface YearEdge {
  node: Year;
  cursor: String;
}

export interface YearEdgePromise extends Promise<YearEdge>, Fragmentable {
  node: <T = YearPromise>() => T;
  cursor: () => Promise<String>;
}

export interface YearEdgeSubscription
  extends Promise<AsyncIterator<YearEdge>>,
    Fragmentable {
  node: <T = YearSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateYear {
  count: Int;
}

export interface AggregateYearPromise
  extends Promise<AggregateYear>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateYearSubscription
  extends Promise<AsyncIterator<AggregateYear>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ClassSubscriptionPayload {
  mutation: MutationType;
  node: Class;
  updatedFields: String[];
  previousValues: ClassPreviousValues;
}

export interface ClassSubscriptionPayloadPromise
  extends Promise<ClassSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassPreviousValuesPromise>() => T;
}

export interface ClassSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassPreviousValuesSubscription>() => T;
}

export interface ClassPreviousValues {
  id: Int;
  className?: String;
  number?: String;
  sortorder?: Int;
  subject?: String;
  subsortorder?: Int;
  url?: String;
}

export interface ClassPreviousValuesPromise
  extends Promise<ClassPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  className: () => Promise<String>;
  number: () => Promise<String>;
  sortorder: () => Promise<Int>;
  subject: () => Promise<String>;
  subsortorder: () => Promise<Int>;
  url: () => Promise<String>;
}

export interface ClassPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  className: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  sortorder: () => Promise<AsyncIterator<Int>>;
  subject: () => Promise<AsyncIterator<String>>;
  subsortorder: () => Promise<AsyncIterator<Int>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface DegreeSubscriptionPayload {
  mutation: MutationType;
  node: Degree;
  updatedFields: String[];
  previousValues: DegreePreviousValues;
}

export interface DegreeSubscriptionPayloadPromise
  extends Promise<DegreeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DegreePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DegreePreviousValuesPromise>() => T;
}

export interface DegreeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DegreeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DegreeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DegreePreviousValuesSubscription>() => T;
}

export interface DegreePreviousValues {
  id: ID_Output;
  description?: String;
  heading?: String;
  icon?: String;
  pathurl?: String;
}

export interface DegreePreviousValuesPromise
  extends Promise<DegreePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  heading: () => Promise<String>;
  icon: () => Promise<String>;
  pathurl: () => Promise<String>;
}

export interface DegreePreviousValuesSubscription
  extends Promise<AsyncIterator<DegreePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  heading: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  pathurl: () => Promise<AsyncIterator<String>>;
}

export interface MetaSubscriptionPayload {
  mutation: MutationType;
  node: Meta;
  updatedFields: String[];
  previousValues: MetaPreviousValues;
}

export interface MetaSubscriptionPayloadPromise
  extends Promise<MetaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MetaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MetaPreviousValuesPromise>() => T;
}

export interface MetaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MetaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MetaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MetaPreviousValuesSubscription>() => T;
}

export interface MetaPreviousValues {
  id: ID_Output;
  abbr?: String;
}

export interface MetaPreviousValuesPromise
  extends Promise<MetaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  abbr: () => Promise<String>;
}

export interface MetaPreviousValuesSubscription
  extends Promise<AsyncIterator<MetaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  abbr: () => Promise<AsyncIterator<String>>;
}

export interface NoncurricularSubscriptionPayload {
  mutation: MutationType;
  node: Noncurricular;
  updatedFields: String[];
  previousValues: NoncurricularPreviousValues;
}

export interface NoncurricularSubscriptionPayloadPromise
  extends Promise<NoncurricularSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NoncurricularPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NoncurricularPreviousValuesPromise>() => T;
}

export interface NoncurricularSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NoncurricularSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NoncurricularSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NoncurricularPreviousValuesSubscription>() => T;
}

export interface NoncurricularPreviousValues {
  id: ID_Output;
  description?: String;
}

export interface NoncurricularPreviousValuesPromise
  extends Promise<NoncurricularPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
}

export interface NoncurricularPreviousValuesSubscription
  extends Promise<AsyncIterator<NoncurricularPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProgramSubscriptionPayload {
  mutation: MutationType;
  node: Program;
  updatedFields: String[];
  previousValues: ProgramPreviousValues;
}

export interface ProgramSubscriptionPayloadPromise
  extends Promise<ProgramSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProgramPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProgramPreviousValuesPromise>() => T;
}

export interface ProgramSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProgramSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProgramSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProgramPreviousValuesSubscription>() => T;
}

export interface ProgramPreviousValues {
  id: ID_Output;
}

export interface ProgramPreviousValuesPromise
  extends Promise<ProgramPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ProgramPreviousValuesSubscription
  extends Promise<AsyncIterator<ProgramPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface RequirementSubscriptionPayload {
  mutation: MutationType;
  node: Requirement;
  updatedFields: String[];
  previousValues: RequirementPreviousValues;
}

export interface RequirementSubscriptionPayloadPromise
  extends Promise<RequirementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RequirementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RequirementPreviousValuesPromise>() => T;
}

export interface RequirementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RequirementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RequirementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RequirementPreviousValuesSubscription>() => T;
}

export interface RequirementPreviousValues {
  id: ID_Output;
  description?: String;
}

export interface RequirementPreviousValuesPromise
  extends Promise<RequirementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
}

export interface RequirementPreviousValuesSubscription
  extends Promise<AsyncIterator<RequirementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface TermSubscriptionPayload {
  mutation: MutationType;
  node: Term;
  updatedFields: String[];
  previousValues: TermPreviousValues;
}

export interface TermSubscriptionPayloadPromise
  extends Promise<TermSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TermPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TermPreviousValuesPromise>() => T;
}

export interface TermSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TermSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TermSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TermPreviousValuesSubscription>() => T;
}

export interface TermPreviousValues {
  id: ID_Output;
  term?: Int;
  termName?: String;
  yearTermTitle?: String;
}

export interface TermPreviousValuesPromise
  extends Promise<TermPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  term: () => Promise<Int>;
  termName: () => Promise<String>;
  yearTermTitle: () => Promise<String>;
}

export interface TermPreviousValuesSubscription
  extends Promise<AsyncIterator<TermPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  term: () => Promise<AsyncIterator<Int>>;
  termName: () => Promise<AsyncIterator<String>>;
  yearTermTitle: () => Promise<AsyncIterator<String>>;
}

export interface YearSubscriptionPayload {
  mutation: MutationType;
  node: Year;
  updatedFields: String[];
  previousValues: YearPreviousValues;
}

export interface YearSubscriptionPayloadPromise
  extends Promise<YearSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = YearPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = YearPreviousValuesPromise>() => T;
}

export interface YearSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<YearSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = YearSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = YearPreviousValuesSubscription>() => T;
}

export interface YearPreviousValues {
  id: ID_Output;
  year?: Int;
}

export interface YearPreviousValuesPromise
  extends Promise<YearPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  year: () => Promise<Int>;
}

export interface YearPreviousValuesSubscription
  extends Promise<AsyncIterator<YearPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  year: () => Promise<AsyncIterator<Int>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Class",
    embedded: false
  },
  {
    name: "Degree",
    embedded: false
  },
  {
    name: "Meta",
    embedded: false
  },
  {
    name: "Noncurricular",
    embedded: false
  },
  {
    name: "Program",
    embedded: false
  },
  {
    name: "Requirement",
    embedded: false
  },
  {
    name: "Term",
    embedded: false
  },
  {
    name: "Year",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
