type AggregateClass {
  count: Int!
}

type AggregateDegree {
  count: Int!
}

type AggregateMeta {
  count: Int!
}

type AggregateNoncurricular {
  count: Int!
}

type AggregateProgram {
  count: Int!
}

type AggregateRequirement {
  count: Int!
}

type AggregateTerm {
  count: Int!
}

type AggregateYear {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Class {
  id: Int!
  className: String
  degreeTitleYearTerm: Term
  number: String
  requirement: Requirement
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

type ClassConnection {
  pageInfo: PageInfo!
  edges: [ClassEdge]!
  aggregate: AggregateClass!
}

input ClassCreateInput {
  className: String
  degreeTitleYearTerm: TermCreateOneWithoutClassesInput
  number: String
  requirement: RequirementCreateOneWithoutClassesInput
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

input ClassCreateManyWithoutDegreeTitleYearTermInput {
  create: [ClassCreateWithoutDegreeTitleYearTermInput!]
  connect: [ClassWhereUniqueInput!]
}

input ClassCreateManyWithoutRequirementInput {
  create: [ClassCreateWithoutRequirementInput!]
  connect: [ClassWhereUniqueInput!]
}

input ClassCreateWithoutDegreeTitleYearTermInput {
  className: String
  number: String
  requirement: RequirementCreateOneWithoutClassesInput
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

input ClassCreateWithoutRequirementInput {
  className: String
  degreeTitleYearTerm: TermCreateOneWithoutClassesInput
  number: String
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

type ClassEdge {
  node: Class!
  cursor: String!
}

enum ClassOrderByInput {
  id_ASC
  id_DESC
  className_ASC
  className_DESC
  number_ASC
  number_DESC
  sortorder_ASC
  sortorder_DESC
  subject_ASC
  subject_DESC
  subsortorder_ASC
  subsortorder_DESC
  url_ASC
  url_DESC
}

type ClassPreviousValues {
  id: Int!
  className: String
  number: String
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

input ClassScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  className: String
  className_not: String
  className_in: [String!]
  className_not_in: [String!]
  className_lt: String
  className_lte: String
  className_gt: String
  className_gte: String
  className_contains: String
  className_not_contains: String
  className_starts_with: String
  className_not_starts_with: String
  className_ends_with: String
  className_not_ends_with: String
  number: String
  number_not: String
  number_in: [String!]
  number_not_in: [String!]
  number_lt: String
  number_lte: String
  number_gt: String
  number_gte: String
  number_contains: String
  number_not_contains: String
  number_starts_with: String
  number_not_starts_with: String
  number_ends_with: String
  number_not_ends_with: String
  sortorder: Int
  sortorder_not: Int
  sortorder_in: [Int!]
  sortorder_not_in: [Int!]
  sortorder_lt: Int
  sortorder_lte: Int
  sortorder_gt: Int
  sortorder_gte: Int
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  subsortorder: Int
  subsortorder_not: Int
  subsortorder_in: [Int!]
  subsortorder_not_in: [Int!]
  subsortorder_lt: Int
  subsortorder_lte: Int
  subsortorder_gt: Int
  subsortorder_gte: Int
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [ClassScalarWhereInput!]
  OR: [ClassScalarWhereInput!]
  NOT: [ClassScalarWhereInput!]
}

type ClassSubscriptionPayload {
  mutation: MutationType!
  node: Class
  updatedFields: [String!]
  previousValues: ClassPreviousValues
}

input ClassSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassWhereInput
  AND: [ClassSubscriptionWhereInput!]
  OR: [ClassSubscriptionWhereInput!]
  NOT: [ClassSubscriptionWhereInput!]
}

input ClassUpdateInput {
  className: String
  degreeTitleYearTerm: TermUpdateOneWithoutClassesInput
  number: String
  requirement: RequirementUpdateOneWithoutClassesInput
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

input ClassUpdateManyDataInput {
  className: String
  number: String
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

input ClassUpdateManyMutationInput {
  className: String
  number: String
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

input ClassUpdateManyWithoutDegreeTitleYearTermInput {
  create: [ClassCreateWithoutDegreeTitleYearTermInput!]
  delete: [ClassWhereUniqueInput!]
  connect: [ClassWhereUniqueInput!]
  set: [ClassWhereUniqueInput!]
  disconnect: [ClassWhereUniqueInput!]
  update: [ClassUpdateWithWhereUniqueWithoutDegreeTitleYearTermInput!]
  upsert: [ClassUpsertWithWhereUniqueWithoutDegreeTitleYearTermInput!]
  deleteMany: [ClassScalarWhereInput!]
  updateMany: [ClassUpdateManyWithWhereNestedInput!]
}

input ClassUpdateManyWithoutRequirementInput {
  create: [ClassCreateWithoutRequirementInput!]
  delete: [ClassWhereUniqueInput!]
  connect: [ClassWhereUniqueInput!]
  set: [ClassWhereUniqueInput!]
  disconnect: [ClassWhereUniqueInput!]
  update: [ClassUpdateWithWhereUniqueWithoutRequirementInput!]
  upsert: [ClassUpsertWithWhereUniqueWithoutRequirementInput!]
  deleteMany: [ClassScalarWhereInput!]
  updateMany: [ClassUpdateManyWithWhereNestedInput!]
}

input ClassUpdateManyWithWhereNestedInput {
  where: ClassScalarWhereInput!
  data: ClassUpdateManyDataInput!
}

input ClassUpdateWithoutDegreeTitleYearTermDataInput {
  className: String
  number: String
  requirement: RequirementUpdateOneWithoutClassesInput
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

input ClassUpdateWithoutRequirementDataInput {
  className: String
  degreeTitleYearTerm: TermUpdateOneWithoutClassesInput
  number: String
  sortorder: Int
  subject: String
  subsortorder: Int
  url: String
}

input ClassUpdateWithWhereUniqueWithoutDegreeTitleYearTermInput {
  where: ClassWhereUniqueInput!
  data: ClassUpdateWithoutDegreeTitleYearTermDataInput!
}

input ClassUpdateWithWhereUniqueWithoutRequirementInput {
  where: ClassWhereUniqueInput!
  data: ClassUpdateWithoutRequirementDataInput!
}

input ClassUpsertWithWhereUniqueWithoutDegreeTitleYearTermInput {
  where: ClassWhereUniqueInput!
  update: ClassUpdateWithoutDegreeTitleYearTermDataInput!
  create: ClassCreateWithoutDegreeTitleYearTermInput!
}

input ClassUpsertWithWhereUniqueWithoutRequirementInput {
  where: ClassWhereUniqueInput!
  update: ClassUpdateWithoutRequirementDataInput!
  create: ClassCreateWithoutRequirementInput!
}

input ClassWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  className: String
  className_not: String
  className_in: [String!]
  className_not_in: [String!]
  className_lt: String
  className_lte: String
  className_gt: String
  className_gte: String
  className_contains: String
  className_not_contains: String
  className_starts_with: String
  className_not_starts_with: String
  className_ends_with: String
  className_not_ends_with: String
  degreeTitleYearTerm: TermWhereInput
  number: String
  number_not: String
  number_in: [String!]
  number_not_in: [String!]
  number_lt: String
  number_lte: String
  number_gt: String
  number_gte: String
  number_contains: String
  number_not_contains: String
  number_starts_with: String
  number_not_starts_with: String
  number_ends_with: String
  number_not_ends_with: String
  requirement: RequirementWhereInput
  sortorder: Int
  sortorder_not: Int
  sortorder_in: [Int!]
  sortorder_not_in: [Int!]
  sortorder_lt: Int
  sortorder_lte: Int
  sortorder_gt: Int
  sortorder_gte: Int
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  subsortorder: Int
  subsortorder_not: Int
  subsortorder_in: [Int!]
  subsortorder_not_in: [Int!]
  subsortorder_lt: Int
  subsortorder_lte: Int
  subsortorder_gt: Int
  subsortorder_gte: Int
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [ClassWhereInput!]
  OR: [ClassWhereInput!]
  NOT: [ClassWhereInput!]
}

input ClassWhereUniqueInput {
  id: Int
}

type Degree {
  id: ID!
  description: String
  heading: String
  icon: String
  pathurl: String
  programTitle: Program
  years(where: YearWhereInput, orderBy: YearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Year!]
}

type DegreeConnection {
  pageInfo: PageInfo!
  edges: [DegreeEdge]!
  aggregate: AggregateDegree!
}

input DegreeCreateInput {
  description: String
  heading: String
  icon: String
  pathurl: String
  programTitle: ProgramCreateOneWithoutDegreesInput
  years: YearCreateManyWithoutDegreeTitleInput
}

input DegreeCreateManyWithoutProgramTitleInput {
  create: [DegreeCreateWithoutProgramTitleInput!]
  connect: [DegreeWhereUniqueInput!]
}

input DegreeCreateOneWithoutYearsInput {
  create: DegreeCreateWithoutYearsInput
  connect: DegreeWhereUniqueInput
}

input DegreeCreateWithoutProgramTitleInput {
  description: String
  heading: String
  icon: String
  pathurl: String
  years: YearCreateManyWithoutDegreeTitleInput
}

input DegreeCreateWithoutYearsInput {
  description: String
  heading: String
  icon: String
  pathurl: String
  programTitle: ProgramCreateOneWithoutDegreesInput
}

type DegreeEdge {
  node: Degree!
  cursor: String!
}

enum DegreeOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  heading_ASC
  heading_DESC
  icon_ASC
  icon_DESC
  pathurl_ASC
  pathurl_DESC
}

type DegreePreviousValues {
  id: ID!
  description: String
  heading: String
  icon: String
  pathurl: String
}

input DegreeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  heading: String
  heading_not: String
  heading_in: [String!]
  heading_not_in: [String!]
  heading_lt: String
  heading_lte: String
  heading_gt: String
  heading_gte: String
  heading_contains: String
  heading_not_contains: String
  heading_starts_with: String
  heading_not_starts_with: String
  heading_ends_with: String
  heading_not_ends_with: String
  icon: String
  icon_not: String
  icon_in: [String!]
  icon_not_in: [String!]
  icon_lt: String
  icon_lte: String
  icon_gt: String
  icon_gte: String
  icon_contains: String
  icon_not_contains: String
  icon_starts_with: String
  icon_not_starts_with: String
  icon_ends_with: String
  icon_not_ends_with: String
  pathurl: String
  pathurl_not: String
  pathurl_in: [String!]
  pathurl_not_in: [String!]
  pathurl_lt: String
  pathurl_lte: String
  pathurl_gt: String
  pathurl_gte: String
  pathurl_contains: String
  pathurl_not_contains: String
  pathurl_starts_with: String
  pathurl_not_starts_with: String
  pathurl_ends_with: String
  pathurl_not_ends_with: String
  AND: [DegreeScalarWhereInput!]
  OR: [DegreeScalarWhereInput!]
  NOT: [DegreeScalarWhereInput!]
}

type DegreeSubscriptionPayload {
  mutation: MutationType!
  node: Degree
  updatedFields: [String!]
  previousValues: DegreePreviousValues
}

input DegreeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DegreeWhereInput
  AND: [DegreeSubscriptionWhereInput!]
  OR: [DegreeSubscriptionWhereInput!]
  NOT: [DegreeSubscriptionWhereInput!]
}

input DegreeUpdateInput {
  description: String
  heading: String
  icon: String
  pathurl: String
  programTitle: ProgramUpdateOneWithoutDegreesInput
  years: YearUpdateManyWithoutDegreeTitleInput
}

input DegreeUpdateManyDataInput {
  description: String
  heading: String
  icon: String
  pathurl: String
}

input DegreeUpdateManyMutationInput {
  description: String
  heading: String
  icon: String
  pathurl: String
}

input DegreeUpdateManyWithoutProgramTitleInput {
  create: [DegreeCreateWithoutProgramTitleInput!]
  delete: [DegreeWhereUniqueInput!]
  connect: [DegreeWhereUniqueInput!]
  set: [DegreeWhereUniqueInput!]
  disconnect: [DegreeWhereUniqueInput!]
  update: [DegreeUpdateWithWhereUniqueWithoutProgramTitleInput!]
  upsert: [DegreeUpsertWithWhereUniqueWithoutProgramTitleInput!]
  deleteMany: [DegreeScalarWhereInput!]
  updateMany: [DegreeUpdateManyWithWhereNestedInput!]
}

input DegreeUpdateManyWithWhereNestedInput {
  where: DegreeScalarWhereInput!
  data: DegreeUpdateManyDataInput!
}

input DegreeUpdateOneWithoutYearsInput {
  create: DegreeCreateWithoutYearsInput
  update: DegreeUpdateWithoutYearsDataInput
  upsert: DegreeUpsertWithoutYearsInput
  delete: Boolean
  disconnect: Boolean
  connect: DegreeWhereUniqueInput
}

input DegreeUpdateWithoutProgramTitleDataInput {
  description: String
  heading: String
  icon: String
  pathurl: String
  years: YearUpdateManyWithoutDegreeTitleInput
}

input DegreeUpdateWithoutYearsDataInput {
  description: String
  heading: String
  icon: String
  pathurl: String
  programTitle: ProgramUpdateOneWithoutDegreesInput
}

input DegreeUpdateWithWhereUniqueWithoutProgramTitleInput {
  where: DegreeWhereUniqueInput!
  data: DegreeUpdateWithoutProgramTitleDataInput!
}

input DegreeUpsertWithoutYearsInput {
  update: DegreeUpdateWithoutYearsDataInput!
  create: DegreeCreateWithoutYearsInput!
}

input DegreeUpsertWithWhereUniqueWithoutProgramTitleInput {
  where: DegreeWhereUniqueInput!
  update: DegreeUpdateWithoutProgramTitleDataInput!
  create: DegreeCreateWithoutProgramTitleInput!
}

input DegreeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  heading: String
  heading_not: String
  heading_in: [String!]
  heading_not_in: [String!]
  heading_lt: String
  heading_lte: String
  heading_gt: String
  heading_gte: String
  heading_contains: String
  heading_not_contains: String
  heading_starts_with: String
  heading_not_starts_with: String
  heading_ends_with: String
  heading_not_ends_with: String
  icon: String
  icon_not: String
  icon_in: [String!]
  icon_not_in: [String!]
  icon_lt: String
  icon_lte: String
  icon_gt: String
  icon_gte: String
  icon_contains: String
  icon_not_contains: String
  icon_starts_with: String
  icon_not_starts_with: String
  icon_ends_with: String
  icon_not_ends_with: String
  pathurl: String
  pathurl_not: String
  pathurl_in: [String!]
  pathurl_not_in: [String!]
  pathurl_lt: String
  pathurl_lte: String
  pathurl_gt: String
  pathurl_gte: String
  pathurl_contains: String
  pathurl_not_contains: String
  pathurl_starts_with: String
  pathurl_not_starts_with: String
  pathurl_ends_with: String
  pathurl_not_ends_with: String
  programTitle: ProgramWhereInput
  years_every: YearWhereInput
  years_some: YearWhereInput
  years_none: YearWhereInput
  AND: [DegreeWhereInput!]
  OR: [DegreeWhereInput!]
  NOT: [DegreeWhereInput!]
}

input DegreeWhereUniqueInput {
  id: ID
}

scalar Long

type Meta {
  id: ID!
  programs(where: ProgramWhereInput, orderBy: ProgramOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Program!]
  abbr: String
}

type MetaConnection {
  pageInfo: PageInfo!
  edges: [MetaEdge]!
  aggregate: AggregateMeta!
}

input MetaCreateInput {
  programs: ProgramCreateManyWithoutMetaTitleInput
  abbr: String
}

input MetaCreateOneWithoutProgramsInput {
  create: MetaCreateWithoutProgramsInput
  connect: MetaWhereUniqueInput
}

input MetaCreateWithoutProgramsInput {
  abbr: String
}

type MetaEdge {
  node: Meta!
  cursor: String!
}

enum MetaOrderByInput {
  id_ASC
  id_DESC
  abbr_ASC
  abbr_DESC
}

type MetaPreviousValues {
  id: ID!
  abbr: String
}

type MetaSubscriptionPayload {
  mutation: MutationType!
  node: Meta
  updatedFields: [String!]
  previousValues: MetaPreviousValues
}

input MetaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MetaWhereInput
  AND: [MetaSubscriptionWhereInput!]
  OR: [MetaSubscriptionWhereInput!]
  NOT: [MetaSubscriptionWhereInput!]
}

input MetaUpdateInput {
  programs: ProgramUpdateManyWithoutMetaTitleInput
  abbr: String
}

input MetaUpdateManyMutationInput {
  abbr: String
}

input MetaUpdateOneWithoutProgramsInput {
  create: MetaCreateWithoutProgramsInput
  update: MetaUpdateWithoutProgramsDataInput
  upsert: MetaUpsertWithoutProgramsInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaWhereUniqueInput
}

input MetaUpdateWithoutProgramsDataInput {
  abbr: String
}

input MetaUpsertWithoutProgramsInput {
  update: MetaUpdateWithoutProgramsDataInput!
  create: MetaCreateWithoutProgramsInput!
}

input MetaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  programs_every: ProgramWhereInput
  programs_some: ProgramWhereInput
  programs_none: ProgramWhereInput
  abbr: String
  abbr_not: String
  abbr_in: [String!]
  abbr_not_in: [String!]
  abbr_lt: String
  abbr_lte: String
  abbr_gt: String
  abbr_gte: String
  abbr_contains: String
  abbr_not_contains: String
  abbr_starts_with: String
  abbr_not_starts_with: String
  abbr_ends_with: String
  abbr_not_ends_with: String
  AND: [MetaWhereInput!]
  OR: [MetaWhereInput!]
  NOT: [MetaWhereInput!]
}

input MetaWhereUniqueInput {
  id: ID
}

type Mutation {
  createClass(data: ClassCreateInput!): Class!
  updateClass(data: ClassUpdateInput!, where: ClassWhereUniqueInput!): Class
  updateManyClasses(data: ClassUpdateManyMutationInput!, where: ClassWhereInput): BatchPayload!
  upsertClass(where: ClassWhereUniqueInput!, create: ClassCreateInput!, update: ClassUpdateInput!): Class!
  deleteClass(where: ClassWhereUniqueInput!): Class
  deleteManyClasses(where: ClassWhereInput): BatchPayload!
  createDegree(data: DegreeCreateInput!): Degree!
  updateDegree(data: DegreeUpdateInput!, where: DegreeWhereUniqueInput!): Degree
  updateManyDegrees(data: DegreeUpdateManyMutationInput!, where: DegreeWhereInput): BatchPayload!
  upsertDegree(where: DegreeWhereUniqueInput!, create: DegreeCreateInput!, update: DegreeUpdateInput!): Degree!
  deleteDegree(where: DegreeWhereUniqueInput!): Degree
  deleteManyDegrees(where: DegreeWhereInput): BatchPayload!
  createMeta(data: MetaCreateInput!): Meta!
  updateMeta(data: MetaUpdateInput!, where: MetaWhereUniqueInput!): Meta
  updateManyMetas(data: MetaUpdateManyMutationInput!, where: MetaWhereInput): BatchPayload!
  upsertMeta(where: MetaWhereUniqueInput!, create: MetaCreateInput!, update: MetaUpdateInput!): Meta!
  deleteMeta(where: MetaWhereUniqueInput!): Meta
  deleteManyMetas(where: MetaWhereInput): BatchPayload!
  createNoncurricular(data: NoncurricularCreateInput!): Noncurricular!
  updateNoncurricular(data: NoncurricularUpdateInput!, where: NoncurricularWhereUniqueInput!): Noncurricular
  updateManyNoncurriculars(data: NoncurricularUpdateManyMutationInput!, where: NoncurricularWhereInput): BatchPayload!
  upsertNoncurricular(where: NoncurricularWhereUniqueInput!, create: NoncurricularCreateInput!, update: NoncurricularUpdateInput!): Noncurricular!
  deleteNoncurricular(where: NoncurricularWhereUniqueInput!): Noncurricular
  deleteManyNoncurriculars(where: NoncurricularWhereInput): BatchPayload!
  createProgram(data: ProgramCreateInput!): Program!
  updateProgram(data: ProgramUpdateInput!, where: ProgramWhereUniqueInput!): Program
  upsertProgram(where: ProgramWhereUniqueInput!, create: ProgramCreateInput!, update: ProgramUpdateInput!): Program!
  deleteProgram(where: ProgramWhereUniqueInput!): Program
  deleteManyPrograms(where: ProgramWhereInput): BatchPayload!
  createRequirement(data: RequirementCreateInput!): Requirement!
  updateRequirement(data: RequirementUpdateInput!, where: RequirementWhereUniqueInput!): Requirement
  updateManyRequirements(data: RequirementUpdateManyMutationInput!, where: RequirementWhereInput): BatchPayload!
  upsertRequirement(where: RequirementWhereUniqueInput!, create: RequirementCreateInput!, update: RequirementUpdateInput!): Requirement!
  deleteRequirement(where: RequirementWhereUniqueInput!): Requirement
  deleteManyRequirements(where: RequirementWhereInput): BatchPayload!
  createTerm(data: TermCreateInput!): Term!
  updateTerm(data: TermUpdateInput!, where: TermWhereUniqueInput!): Term
  updateManyTerms(data: TermUpdateManyMutationInput!, where: TermWhereInput): BatchPayload!
  upsertTerm(where: TermWhereUniqueInput!, create: TermCreateInput!, update: TermUpdateInput!): Term!
  deleteTerm(where: TermWhereUniqueInput!): Term
  deleteManyTerms(where: TermWhereInput): BatchPayload!
  createYear(data: YearCreateInput!): Year!
  updateYear(data: YearUpdateInput!, where: YearWhereUniqueInput!): Year
  updateManyYears(data: YearUpdateManyMutationInput!, where: YearWhereInput): BatchPayload!
  upsertYear(where: YearWhereUniqueInput!, create: YearCreateInput!, update: YearUpdateInput!): Year!
  deleteYear(where: YearWhereUniqueInput!): Year
  deleteManyYears(where: YearWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Noncurricular {
  id: ID!
  description: String
  terms(where: TermWhereInput, orderBy: TermOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Term!]
}

type NoncurricularConnection {
  pageInfo: PageInfo!
  edges: [NoncurricularEdge]!
  aggregate: AggregateNoncurricular!
}

input NoncurricularCreateInput {
  description: String
  terms: TermCreateManyWithoutNoncurricularInput
}

input NoncurricularCreateOneWithoutTermsInput {
  create: NoncurricularCreateWithoutTermsInput
  connect: NoncurricularWhereUniqueInput
}

input NoncurricularCreateWithoutTermsInput {
  description: String
}

type NoncurricularEdge {
  node: Noncurricular!
  cursor: String!
}

enum NoncurricularOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
}

type NoncurricularPreviousValues {
  id: ID!
  description: String
}

type NoncurricularSubscriptionPayload {
  mutation: MutationType!
  node: Noncurricular
  updatedFields: [String!]
  previousValues: NoncurricularPreviousValues
}

input NoncurricularSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NoncurricularWhereInput
  AND: [NoncurricularSubscriptionWhereInput!]
  OR: [NoncurricularSubscriptionWhereInput!]
  NOT: [NoncurricularSubscriptionWhereInput!]
}

input NoncurricularUpdateInput {
  description: String
  terms: TermUpdateManyWithoutNoncurricularInput
}

input NoncurricularUpdateManyMutationInput {
  description: String
}

input NoncurricularUpdateOneWithoutTermsInput {
  create: NoncurricularCreateWithoutTermsInput
  update: NoncurricularUpdateWithoutTermsDataInput
  upsert: NoncurricularUpsertWithoutTermsInput
  delete: Boolean
  disconnect: Boolean
  connect: NoncurricularWhereUniqueInput
}

input NoncurricularUpdateWithoutTermsDataInput {
  description: String
}

input NoncurricularUpsertWithoutTermsInput {
  update: NoncurricularUpdateWithoutTermsDataInput!
  create: NoncurricularCreateWithoutTermsInput!
}

input NoncurricularWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  terms_every: TermWhereInput
  terms_some: TermWhereInput
  terms_none: TermWhereInput
  AND: [NoncurricularWhereInput!]
  OR: [NoncurricularWhereInput!]
  NOT: [NoncurricularWhereInput!]
}

input NoncurricularWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Program {
  id: ID!
  degrees(where: DegreeWhereInput, orderBy: DegreeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Degree!]
  metaTitle: Meta
}

type ProgramConnection {
  pageInfo: PageInfo!
  edges: [ProgramEdge]!
  aggregate: AggregateProgram!
}

input ProgramCreateInput {
  degrees: DegreeCreateManyWithoutProgramTitleInput
  metaTitle: MetaCreateOneWithoutProgramsInput
}

input ProgramCreateManyWithoutMetaTitleInput {
  create: [ProgramCreateWithoutMetaTitleInput!]
  connect: [ProgramWhereUniqueInput!]
}

input ProgramCreateOneWithoutDegreesInput {
  create: ProgramCreateWithoutDegreesInput
  connect: ProgramWhereUniqueInput
}

input ProgramCreateWithoutDegreesInput {
  metaTitle: MetaCreateOneWithoutProgramsInput
}

input ProgramCreateWithoutMetaTitleInput {
  degrees: DegreeCreateManyWithoutProgramTitleInput
}

type ProgramEdge {
  node: Program!
  cursor: String!
}

enum ProgramOrderByInput {
  id_ASC
  id_DESC
}

type ProgramPreviousValues {
  id: ID!
}

input ProgramScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ProgramScalarWhereInput!]
  OR: [ProgramScalarWhereInput!]
  NOT: [ProgramScalarWhereInput!]
}

type ProgramSubscriptionPayload {
  mutation: MutationType!
  node: Program
  updatedFields: [String!]
  previousValues: ProgramPreviousValues
}

input ProgramSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProgramWhereInput
  AND: [ProgramSubscriptionWhereInput!]
  OR: [ProgramSubscriptionWhereInput!]
  NOT: [ProgramSubscriptionWhereInput!]
}

input ProgramUpdateInput {
  degrees: DegreeUpdateManyWithoutProgramTitleInput
  metaTitle: MetaUpdateOneWithoutProgramsInput
}

input ProgramUpdateManyWithoutMetaTitleInput {
  create: [ProgramCreateWithoutMetaTitleInput!]
  delete: [ProgramWhereUniqueInput!]
  connect: [ProgramWhereUniqueInput!]
  set: [ProgramWhereUniqueInput!]
  disconnect: [ProgramWhereUniqueInput!]
  update: [ProgramUpdateWithWhereUniqueWithoutMetaTitleInput!]
  upsert: [ProgramUpsertWithWhereUniqueWithoutMetaTitleInput!]
  deleteMany: [ProgramScalarWhereInput!]
}

input ProgramUpdateOneWithoutDegreesInput {
  create: ProgramCreateWithoutDegreesInput
  update: ProgramUpdateWithoutDegreesDataInput
  upsert: ProgramUpsertWithoutDegreesInput
  delete: Boolean
  disconnect: Boolean
  connect: ProgramWhereUniqueInput
}

input ProgramUpdateWithoutDegreesDataInput {
  metaTitle: MetaUpdateOneWithoutProgramsInput
}

input ProgramUpdateWithoutMetaTitleDataInput {
  degrees: DegreeUpdateManyWithoutProgramTitleInput
}

input ProgramUpdateWithWhereUniqueWithoutMetaTitleInput {
  where: ProgramWhereUniqueInput!
  data: ProgramUpdateWithoutMetaTitleDataInput!
}

input ProgramUpsertWithoutDegreesInput {
  update: ProgramUpdateWithoutDegreesDataInput!
  create: ProgramCreateWithoutDegreesInput!
}

input ProgramUpsertWithWhereUniqueWithoutMetaTitleInput {
  where: ProgramWhereUniqueInput!
  update: ProgramUpdateWithoutMetaTitleDataInput!
  create: ProgramCreateWithoutMetaTitleInput!
}

input ProgramWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  degrees_every: DegreeWhereInput
  degrees_some: DegreeWhereInput
  degrees_none: DegreeWhereInput
  metaTitle: MetaWhereInput
  AND: [ProgramWhereInput!]
  OR: [ProgramWhereInput!]
  NOT: [ProgramWhereInput!]
}

input ProgramWhereUniqueInput {
  id: ID
}

type Query {
  class(where: ClassWhereUniqueInput!): Class
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class]!
  classesConnection(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassConnection!
  degree(where: DegreeWhereUniqueInput!): Degree
  degrees(where: DegreeWhereInput, orderBy: DegreeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Degree]!
  degreesConnection(where: DegreeWhereInput, orderBy: DegreeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DegreeConnection!
  meta(where: MetaWhereUniqueInput!): Meta
  metas(where: MetaWhereInput, orderBy: MetaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Meta]!
  metasConnection(where: MetaWhereInput, orderBy: MetaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MetaConnection!
  noncurricular(where: NoncurricularWhereUniqueInput!): Noncurricular
  noncurriculars(where: NoncurricularWhereInput, orderBy: NoncurricularOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Noncurricular]!
  noncurricularsConnection(where: NoncurricularWhereInput, orderBy: NoncurricularOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NoncurricularConnection!
  program(where: ProgramWhereUniqueInput!): Program
  programs(where: ProgramWhereInput, orderBy: ProgramOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Program]!
  programsConnection(where: ProgramWhereInput, orderBy: ProgramOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProgramConnection!
  requirement(where: RequirementWhereUniqueInput!): Requirement
  requirements(where: RequirementWhereInput, orderBy: RequirementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Requirement]!
  requirementsConnection(where: RequirementWhereInput, orderBy: RequirementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RequirementConnection!
  term(where: TermWhereUniqueInput!): Term
  terms(where: TermWhereInput, orderBy: TermOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Term]!
  termsConnection(where: TermWhereInput, orderBy: TermOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TermConnection!
  year(where: YearWhereUniqueInput!): Year
  years(where: YearWhereInput, orderBy: YearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Year]!
  yearsConnection(where: YearWhereInput, orderBy: YearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): YearConnection!
  node(id: ID!): Node
}

type Requirement {
  id: ID!
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class!]
  description: String
}

type RequirementConnection {
  pageInfo: PageInfo!
  edges: [RequirementEdge]!
  aggregate: AggregateRequirement!
}

input RequirementCreateInput {
  classes: ClassCreateManyWithoutRequirementInput
  description: String
}

input RequirementCreateOneWithoutClassesInput {
  create: RequirementCreateWithoutClassesInput
  connect: RequirementWhereUniqueInput
}

input RequirementCreateWithoutClassesInput {
  description: String
}

type RequirementEdge {
  node: Requirement!
  cursor: String!
}

enum RequirementOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
}

type RequirementPreviousValues {
  id: ID!
  description: String
}

type RequirementSubscriptionPayload {
  mutation: MutationType!
  node: Requirement
  updatedFields: [String!]
  previousValues: RequirementPreviousValues
}

input RequirementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RequirementWhereInput
  AND: [RequirementSubscriptionWhereInput!]
  OR: [RequirementSubscriptionWhereInput!]
  NOT: [RequirementSubscriptionWhereInput!]
}

input RequirementUpdateInput {
  classes: ClassUpdateManyWithoutRequirementInput
  description: String
}

input RequirementUpdateManyMutationInput {
  description: String
}

input RequirementUpdateOneWithoutClassesInput {
  create: RequirementCreateWithoutClassesInput
  update: RequirementUpdateWithoutClassesDataInput
  upsert: RequirementUpsertWithoutClassesInput
  delete: Boolean
  disconnect: Boolean
  connect: RequirementWhereUniqueInput
}

input RequirementUpdateWithoutClassesDataInput {
  description: String
}

input RequirementUpsertWithoutClassesInput {
  update: RequirementUpdateWithoutClassesDataInput!
  create: RequirementCreateWithoutClassesInput!
}

input RequirementWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  classes_every: ClassWhereInput
  classes_some: ClassWhereInput
  classes_none: ClassWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [RequirementWhereInput!]
  OR: [RequirementWhereInput!]
  NOT: [RequirementWhereInput!]
}

input RequirementWhereUniqueInput {
  id: ID
}

type Subscription {
  class(where: ClassSubscriptionWhereInput): ClassSubscriptionPayload
  degree(where: DegreeSubscriptionWhereInput): DegreeSubscriptionPayload
  meta(where: MetaSubscriptionWhereInput): MetaSubscriptionPayload
  noncurricular(where: NoncurricularSubscriptionWhereInput): NoncurricularSubscriptionPayload
  program(where: ProgramSubscriptionWhereInput): ProgramSubscriptionPayload
  requirement(where: RequirementSubscriptionWhereInput): RequirementSubscriptionPayload
  term(where: TermSubscriptionWhereInput): TermSubscriptionPayload
  year(where: YearSubscriptionWhereInput): YearSubscriptionPayload
}

type Term {
  id: ID!
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class!]
  degreeTitleYear: Year
  noncurricular: Noncurricular
  term: Int
  termName: String
  yearTermTitle: String
}

type TermConnection {
  pageInfo: PageInfo!
  edges: [TermEdge]!
  aggregate: AggregateTerm!
}

input TermCreateInput {
  classes: ClassCreateManyWithoutDegreeTitleYearTermInput
  degreeTitleYear: YearCreateOneWithoutTermsInput
  noncurricular: NoncurricularCreateOneWithoutTermsInput
  term: Int
  termName: String
  yearTermTitle: String
}

input TermCreateManyWithoutDegreeTitleYearInput {
  create: [TermCreateWithoutDegreeTitleYearInput!]
  connect: [TermWhereUniqueInput!]
}

input TermCreateManyWithoutNoncurricularInput {
  create: [TermCreateWithoutNoncurricularInput!]
  connect: [TermWhereUniqueInput!]
}

input TermCreateOneWithoutClassesInput {
  create: TermCreateWithoutClassesInput
  connect: TermWhereUniqueInput
}

input TermCreateWithoutClassesInput {
  degreeTitleYear: YearCreateOneWithoutTermsInput
  noncurricular: NoncurricularCreateOneWithoutTermsInput
  term: Int
  termName: String
  yearTermTitle: String
}

input TermCreateWithoutDegreeTitleYearInput {
  classes: ClassCreateManyWithoutDegreeTitleYearTermInput
  noncurricular: NoncurricularCreateOneWithoutTermsInput
  term: Int
  termName: String
  yearTermTitle: String
}

input TermCreateWithoutNoncurricularInput {
  classes: ClassCreateManyWithoutDegreeTitleYearTermInput
  degreeTitleYear: YearCreateOneWithoutTermsInput
  term: Int
  termName: String
  yearTermTitle: String
}

type TermEdge {
  node: Term!
  cursor: String!
}

enum TermOrderByInput {
  id_ASC
  id_DESC
  term_ASC
  term_DESC
  termName_ASC
  termName_DESC
  yearTermTitle_ASC
  yearTermTitle_DESC
}

type TermPreviousValues {
  id: ID!
  term: Int
  termName: String
  yearTermTitle: String
}

input TermScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  term: Int
  term_not: Int
  term_in: [Int!]
  term_not_in: [Int!]
  term_lt: Int
  term_lte: Int
  term_gt: Int
  term_gte: Int
  termName: String
  termName_not: String
  termName_in: [String!]
  termName_not_in: [String!]
  termName_lt: String
  termName_lte: String
  termName_gt: String
  termName_gte: String
  termName_contains: String
  termName_not_contains: String
  termName_starts_with: String
  termName_not_starts_with: String
  termName_ends_with: String
  termName_not_ends_with: String
  yearTermTitle: String
  yearTermTitle_not: String
  yearTermTitle_in: [String!]
  yearTermTitle_not_in: [String!]
  yearTermTitle_lt: String
  yearTermTitle_lte: String
  yearTermTitle_gt: String
  yearTermTitle_gte: String
  yearTermTitle_contains: String
  yearTermTitle_not_contains: String
  yearTermTitle_starts_with: String
  yearTermTitle_not_starts_with: String
  yearTermTitle_ends_with: String
  yearTermTitle_not_ends_with: String
  AND: [TermScalarWhereInput!]
  OR: [TermScalarWhereInput!]
  NOT: [TermScalarWhereInput!]
}

type TermSubscriptionPayload {
  mutation: MutationType!
  node: Term
  updatedFields: [String!]
  previousValues: TermPreviousValues
}

input TermSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TermWhereInput
  AND: [TermSubscriptionWhereInput!]
  OR: [TermSubscriptionWhereInput!]
  NOT: [TermSubscriptionWhereInput!]
}

input TermUpdateInput {
  classes: ClassUpdateManyWithoutDegreeTitleYearTermInput
  degreeTitleYear: YearUpdateOneWithoutTermsInput
  noncurricular: NoncurricularUpdateOneWithoutTermsInput
  term: Int
  termName: String
  yearTermTitle: String
}

input TermUpdateManyDataInput {
  term: Int
  termName: String
  yearTermTitle: String
}

input TermUpdateManyMutationInput {
  term: Int
  termName: String
  yearTermTitle: String
}

input TermUpdateManyWithoutDegreeTitleYearInput {
  create: [TermCreateWithoutDegreeTitleYearInput!]
  delete: [TermWhereUniqueInput!]
  connect: [TermWhereUniqueInput!]
  set: [TermWhereUniqueInput!]
  disconnect: [TermWhereUniqueInput!]
  update: [TermUpdateWithWhereUniqueWithoutDegreeTitleYearInput!]
  upsert: [TermUpsertWithWhereUniqueWithoutDegreeTitleYearInput!]
  deleteMany: [TermScalarWhereInput!]
  updateMany: [TermUpdateManyWithWhereNestedInput!]
}

input TermUpdateManyWithoutNoncurricularInput {
  create: [TermCreateWithoutNoncurricularInput!]
  delete: [TermWhereUniqueInput!]
  connect: [TermWhereUniqueInput!]
  set: [TermWhereUniqueInput!]
  disconnect: [TermWhereUniqueInput!]
  update: [TermUpdateWithWhereUniqueWithoutNoncurricularInput!]
  upsert: [TermUpsertWithWhereUniqueWithoutNoncurricularInput!]
  deleteMany: [TermScalarWhereInput!]
  updateMany: [TermUpdateManyWithWhereNestedInput!]
}

input TermUpdateManyWithWhereNestedInput {
  where: TermScalarWhereInput!
  data: TermUpdateManyDataInput!
}

input TermUpdateOneWithoutClassesInput {
  create: TermCreateWithoutClassesInput
  update: TermUpdateWithoutClassesDataInput
  upsert: TermUpsertWithoutClassesInput
  delete: Boolean
  disconnect: Boolean
  connect: TermWhereUniqueInput
}

input TermUpdateWithoutClassesDataInput {
  degreeTitleYear: YearUpdateOneWithoutTermsInput
  noncurricular: NoncurricularUpdateOneWithoutTermsInput
  term: Int
  termName: String
  yearTermTitle: String
}

input TermUpdateWithoutDegreeTitleYearDataInput {
  classes: ClassUpdateManyWithoutDegreeTitleYearTermInput
  noncurricular: NoncurricularUpdateOneWithoutTermsInput
  term: Int
  termName: String
  yearTermTitle: String
}

input TermUpdateWithoutNoncurricularDataInput {
  classes: ClassUpdateManyWithoutDegreeTitleYearTermInput
  degreeTitleYear: YearUpdateOneWithoutTermsInput
  term: Int
  termName: String
  yearTermTitle: String
}

input TermUpdateWithWhereUniqueWithoutDegreeTitleYearInput {
  where: TermWhereUniqueInput!
  data: TermUpdateWithoutDegreeTitleYearDataInput!
}

input TermUpdateWithWhereUniqueWithoutNoncurricularInput {
  where: TermWhereUniqueInput!
  data: TermUpdateWithoutNoncurricularDataInput!
}

input TermUpsertWithoutClassesInput {
  update: TermUpdateWithoutClassesDataInput!
  create: TermCreateWithoutClassesInput!
}

input TermUpsertWithWhereUniqueWithoutDegreeTitleYearInput {
  where: TermWhereUniqueInput!
  update: TermUpdateWithoutDegreeTitleYearDataInput!
  create: TermCreateWithoutDegreeTitleYearInput!
}

input TermUpsertWithWhereUniqueWithoutNoncurricularInput {
  where: TermWhereUniqueInput!
  update: TermUpdateWithoutNoncurricularDataInput!
  create: TermCreateWithoutNoncurricularInput!
}

input TermWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  classes_every: ClassWhereInput
  classes_some: ClassWhereInput
  classes_none: ClassWhereInput
  degreeTitleYear: YearWhereInput
  noncurricular: NoncurricularWhereInput
  term: Int
  term_not: Int
  term_in: [Int!]
  term_not_in: [Int!]
  term_lt: Int
  term_lte: Int
  term_gt: Int
  term_gte: Int
  termName: String
  termName_not: String
  termName_in: [String!]
  termName_not_in: [String!]
  termName_lt: String
  termName_lte: String
  termName_gt: String
  termName_gte: String
  termName_contains: String
  termName_not_contains: String
  termName_starts_with: String
  termName_not_starts_with: String
  termName_ends_with: String
  termName_not_ends_with: String
  yearTermTitle: String
  yearTermTitle_not: String
  yearTermTitle_in: [String!]
  yearTermTitle_not_in: [String!]
  yearTermTitle_lt: String
  yearTermTitle_lte: String
  yearTermTitle_gt: String
  yearTermTitle_gte: String
  yearTermTitle_contains: String
  yearTermTitle_not_contains: String
  yearTermTitle_starts_with: String
  yearTermTitle_not_starts_with: String
  yearTermTitle_ends_with: String
  yearTermTitle_not_ends_with: String
  AND: [TermWhereInput!]
  OR: [TermWhereInput!]
  NOT: [TermWhereInput!]
}

input TermWhereUniqueInput {
  id: ID
}

type Year {
  id: ID!
  degreeTitle: Degree
  terms(where: TermWhereInput, orderBy: TermOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Term!]
  year: Int
}

type YearConnection {
  pageInfo: PageInfo!
  edges: [YearEdge]!
  aggregate: AggregateYear!
}

input YearCreateInput {
  degreeTitle: DegreeCreateOneWithoutYearsInput
  terms: TermCreateManyWithoutDegreeTitleYearInput
  year: Int
}

input YearCreateManyWithoutDegreeTitleInput {
  create: [YearCreateWithoutDegreeTitleInput!]
  connect: [YearWhereUniqueInput!]
}

input YearCreateOneWithoutTermsInput {
  create: YearCreateWithoutTermsInput
  connect: YearWhereUniqueInput
}

input YearCreateWithoutDegreeTitleInput {
  terms: TermCreateManyWithoutDegreeTitleYearInput
  year: Int
}

input YearCreateWithoutTermsInput {
  degreeTitle: DegreeCreateOneWithoutYearsInput
  year: Int
}

type YearEdge {
  node: Year!
  cursor: String!
}

enum YearOrderByInput {
  id_ASC
  id_DESC
  year_ASC
  year_DESC
}

type YearPreviousValues {
  id: ID!
  year: Int
}

input YearScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  AND: [YearScalarWhereInput!]
  OR: [YearScalarWhereInput!]
  NOT: [YearScalarWhereInput!]
}

type YearSubscriptionPayload {
  mutation: MutationType!
  node: Year
  updatedFields: [String!]
  previousValues: YearPreviousValues
}

input YearSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: YearWhereInput
  AND: [YearSubscriptionWhereInput!]
  OR: [YearSubscriptionWhereInput!]
  NOT: [YearSubscriptionWhereInput!]
}

input YearUpdateInput {
  degreeTitle: DegreeUpdateOneWithoutYearsInput
  terms: TermUpdateManyWithoutDegreeTitleYearInput
  year: Int
}

input YearUpdateManyDataInput {
  year: Int
}

input YearUpdateManyMutationInput {
  year: Int
}

input YearUpdateManyWithoutDegreeTitleInput {
  create: [YearCreateWithoutDegreeTitleInput!]
  delete: [YearWhereUniqueInput!]
  connect: [YearWhereUniqueInput!]
  set: [YearWhereUniqueInput!]
  disconnect: [YearWhereUniqueInput!]
  update: [YearUpdateWithWhereUniqueWithoutDegreeTitleInput!]
  upsert: [YearUpsertWithWhereUniqueWithoutDegreeTitleInput!]
  deleteMany: [YearScalarWhereInput!]
  updateMany: [YearUpdateManyWithWhereNestedInput!]
}

input YearUpdateManyWithWhereNestedInput {
  where: YearScalarWhereInput!
  data: YearUpdateManyDataInput!
}

input YearUpdateOneWithoutTermsInput {
  create: YearCreateWithoutTermsInput
  update: YearUpdateWithoutTermsDataInput
  upsert: YearUpsertWithoutTermsInput
  delete: Boolean
  disconnect: Boolean
  connect: YearWhereUniqueInput
}

input YearUpdateWithoutDegreeTitleDataInput {
  terms: TermUpdateManyWithoutDegreeTitleYearInput
  year: Int
}

input YearUpdateWithoutTermsDataInput {
  degreeTitle: DegreeUpdateOneWithoutYearsInput
  year: Int
}

input YearUpdateWithWhereUniqueWithoutDegreeTitleInput {
  where: YearWhereUniqueInput!
  data: YearUpdateWithoutDegreeTitleDataInput!
}

input YearUpsertWithoutTermsInput {
  update: YearUpdateWithoutTermsDataInput!
  create: YearCreateWithoutTermsInput!
}

input YearUpsertWithWhereUniqueWithoutDegreeTitleInput {
  where: YearWhereUniqueInput!
  update: YearUpdateWithoutDegreeTitleDataInput!
  create: YearCreateWithoutDegreeTitleInput!
}

input YearWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  degreeTitle: DegreeWhereInput
  terms_every: TermWhereInput
  terms_some: TermWhereInput
  terms_none: TermWhereInput
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  AND: [YearWhereInput!]
  OR: [YearWhereInput!]
  NOT: [YearWhereInput!]
}

input YearWhereUniqueInput {
  id: ID
}